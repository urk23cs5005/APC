{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "view-in-github",
        "colab_type": "text"
      },
      "source": [
        "<a href=\"https://colab.research.google.com/github/urk23cs5005/APC/blob/main/ruben_py.ipynb%20asw2in\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "jrp12BMy762D"
      },
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "e078a5d0"
      },
      "source": [
        "# Task\n",
        "Train a machine learning model on the dataset provided in \"/content/diabetes.csv\" to predict the target variable and evaluate its performance."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "08026b78"
      },
      "source": [
        "## Load data\n",
        "\n",
        "### Subtask:\n",
        "Load the dataset from the provided CSV file into a pandas DataFrame.\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "dd330162"
      },
      "source": [
        "**Reasoning**:\n",
        "Import the pandas library, read the CSV file into a DataFrame, and display the first few rows.\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 1,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 356
        },
        "id": "0ac4198a",
        "outputId": "b7f38c42-dfc2-4442-a93b-cad02c7d55a6",
        "collapsed": true
      },
      "outputs": [
        {
          "output_type": "error",
          "ename": "FileNotFoundError",
          "evalue": "[Errno 2] No such file or directory: '/content/diabetes.csv'",
          "traceback": [
            "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
            "\u001b[0;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
            "\u001b[0;32m/tmp/ipython-input-14770977.py\u001b[0m in \u001b[0;36m<cell line: 0>\u001b[0;34m()\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mpandas\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0mpd\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      2\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 3\u001b[0;31m \u001b[0mdf\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mpd\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mread_csv\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"/content/diabetes.csv\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      4\u001b[0m \u001b[0mdisplay\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdf\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mhead\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.12/dist-packages/pandas/io/parsers/readers.py\u001b[0m in \u001b[0;36mread_csv\u001b[0;34m(filepath_or_buffer, sep, delimiter, header, names, index_col, usecols, dtype, engine, converters, true_values, false_values, skipinitialspace, skiprows, skipfooter, nrows, na_values, keep_default_na, na_filter, verbose, skip_blank_lines, parse_dates, infer_datetime_format, keep_date_col, date_parser, date_format, dayfirst, cache_dates, iterator, chunksize, compression, thousands, decimal, lineterminator, quotechar, quoting, doublequote, escapechar, comment, encoding, encoding_errors, dialect, on_bad_lines, delim_whitespace, low_memory, memory_map, float_precision, storage_options, dtype_backend)\u001b[0m\n\u001b[1;32m   1024\u001b[0m     \u001b[0mkwds\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mupdate\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mkwds_defaults\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1025\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1026\u001b[0;31m     \u001b[0;32mreturn\u001b[0m \u001b[0m_read\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfilepath_or_buffer\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mkwds\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1027\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1028\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.12/dist-packages/pandas/io/parsers/readers.py\u001b[0m in \u001b[0;36m_read\u001b[0;34m(filepath_or_buffer, kwds)\u001b[0m\n\u001b[1;32m    618\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    619\u001b[0m     \u001b[0;31m# Create the parser.\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 620\u001b[0;31m     \u001b[0mparser\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mTextFileReader\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfilepath_or_buffer\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwds\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    621\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    622\u001b[0m     \u001b[0;32mif\u001b[0m \u001b[0mchunksize\u001b[0m \u001b[0;32mor\u001b[0m \u001b[0miterator\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.12/dist-packages/pandas/io/parsers/readers.py\u001b[0m in \u001b[0;36m__init__\u001b[0;34m(self, f, engine, **kwds)\u001b[0m\n\u001b[1;32m   1618\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1619\u001b[0m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mhandles\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mIOHandles\u001b[0m \u001b[0;34m|\u001b[0m \u001b[0;32mNone\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1620\u001b[0;31m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_engine\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_make_engine\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mf\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mengine\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1621\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1622\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0mclose\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.12/dist-packages/pandas/io/parsers/readers.py\u001b[0m in \u001b[0;36m_make_engine\u001b[0;34m(self, f, engine)\u001b[0m\n\u001b[1;32m   1878\u001b[0m                 \u001b[0;32mif\u001b[0m \u001b[0;34m\"b\"\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mmode\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1879\u001b[0m                     \u001b[0mmode\u001b[0m \u001b[0;34m+=\u001b[0m \u001b[0;34m\"b\"\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1880\u001b[0;31m             self.handles = get_handle(\n\u001b[0m\u001b[1;32m   1881\u001b[0m                 \u001b[0mf\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1882\u001b[0m                 \u001b[0mmode\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.12/dist-packages/pandas/io/common.py\u001b[0m in \u001b[0;36mget_handle\u001b[0;34m(path_or_buf, mode, encoding, compression, memory_map, is_text, errors, storage_options)\u001b[0m\n\u001b[1;32m    871\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0mioargs\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mencoding\u001b[0m \u001b[0;32mand\u001b[0m \u001b[0;34m\"b\"\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mioargs\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmode\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    872\u001b[0m             \u001b[0;31m# Encoding\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 873\u001b[0;31m             handle = open(\n\u001b[0m\u001b[1;32m    874\u001b[0m                 \u001b[0mhandle\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    875\u001b[0m                 \u001b[0mioargs\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmode\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;31mFileNotFoundError\u001b[0m: [Errno 2] No such file or directory: '/content/diabetes.csv'"
          ]
        }
      ],
      "source": [
        "import pandas as pd\n",
        "\n",
        "df = pd.read_csv(\"/content/diabetes.csv\")\n",
        "display(df.head())"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "92c81ece"
      },
      "source": [
        "## Prepare data\n",
        "\n",
        "### Subtask:\n",
        "Separate the features (independent variables) and the target (dependent variable) for training the model.\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "09d5b2de"
      },
      "source": [
        "**Reasoning**:\n",
        "Separate the features (independent variables) into X and the target (dependent variable) into y.\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "29e0d428",
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 158
        },
        "outputId": "419e0891-e800-43c3-a8cd-3b38c45de2c1"
      },
      "outputs": [
        {
          "output_type": "error",
          "ename": "NameError",
          "evalue": "name 'df' is not defined",
          "traceback": [
            "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
            "\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)",
            "\u001b[0;32m/tmp/ipython-input-970240750.py\u001b[0m in \u001b[0;36m<cell line: 0>\u001b[0;34m()\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0mX\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mdf\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdrop\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'Outcome'\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0maxis\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      2\u001b[0m \u001b[0my\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mdf\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m'Outcome'\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;31mNameError\u001b[0m: name 'df' is not defined"
          ]
        }
      ],
      "source": [
        "X = df.drop('Outcome', axis=1)\n",
        "y = df['Outcome']"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "780425c0"
      },
      "source": [
        "## Load data\n",
        "\n",
        "### Subtask:\n",
        "Load the dataset from the provided CSV file into a pandas DataFrame."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "75bfce63"
      },
      "source": [
        "**Reasoning**:\n",
        "Import the pandas library, read the CSV file into a DataFrame, and display the first few rows."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "768acb64"
      },
      "source": [
        "import pandas as pd\n",
        "\n",
        "df = pd.read_csv(\"/content/diabetes.csv\")\n",
        "display(df.head())"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "07b66c2d"
      },
      "source": [
        "## Prepare data\n",
        "\n",
        "### Subtask:\n",
        "Separate the features (independent variables) and the target (dependent variable) for training the model."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "a7a76e95"
      },
      "source": [
        "**Reasoning**:\n",
        "Separate the features (independent variables) into X and the target (dependent variable) into y."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "8dd11fcb"
      },
      "source": [
        "X = df.drop('Outcome', axis=1)\n",
        "y = df['Outcome']"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "be29294d"
      },
      "source": [
        "## Split data\n",
        "\n",
        "### Subtask:\n",
        "Split the dataset into training and testing sets to evaluate the model's performance on unseen data."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "7ca46a74"
      },
      "source": [
        "**Reasoning**:\n",
        "Split the data into training and testing sets as instructed."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "e51dd405"
      },
      "source": [
        "from sklearn.model_selection import train_test_split\n",
        "\n",
        "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=42)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "8da6821a"
      },
      "source": [
        "## Train model\n",
        "\n",
        "### Subtask:\n",
        "Choose and train a suitable model on the training data."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "f2fe3908"
      },
      "source": [
        "**Reasoning**:\n",
        "Import the Logistic Regression model, instantiate it, and fit it to the training data."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "989f7aab"
      },
      "source": [
        "from sklearn.linear_model import LogisticRegression\n",
        "\n",
        "model = LogisticRegression(random_state=42, max_iter=1000)\n",
        "model.fit(X_train, y_train)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "aa485dee"
      },
      "source": [
        "## Evaluate model\n",
        "\n",
        "### Subtask:\n",
        "Evaluate the trained model on the testing data using appropriate metrics."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "f1910d4a"
      },
      "source": [
        "**Reasoning**:\n",
        "Evaluate the trained model using accuracy and classification report."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "e6b78fc1"
      },
      "source": [
        "from sklearn.metrics import accuracy_score, classification_report\n",
        "\n",
        "# Make predictions on test data\n",
        "y_pred = model.predict(X_test)\n",
        "\n",
        "# Calculate accuracy\n",
        "accuracy = accuracy_score(y_test, y_pred) * 100  # Convert to percentage\n",
        "\n",
        "# Generate classification report\n",
        "report = classification_report(y_test, y_pred)\n",
        "\n",
        "# Print results\n",
        "print(f\"Accuracy: {accuracy:.2f}%\")\n",
        "print(\"Classification Report:\")\n",
        "print(report)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "b6119ab8"
      },
      "source": [
        "## Split data\n",
        "\n",
        "### Subtask:\n",
        "Split the dataset into training and testing sets to evaluate the model's performance on unseen data.\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "1345a39d"
      },
      "source": [
        "**Reasoning**:\n",
        "Split the data into training and testing sets as instructed.\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "7303f0e7",
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 176
        },
        "outputId": "08fc62a1-84ab-4e87-8cf7-91e6bb62b51f"
      },
      "outputs": [
        {
          "output_type": "error",
          "ename": "NameError",
          "evalue": "name 'X' is not defined",
          "traceback": [
            "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
            "\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)",
            "\u001b[0;32m/tmp/ipython-input-669752868.py\u001b[0m in \u001b[0;36m<cell line: 0>\u001b[0;34m()\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[0;32mfrom\u001b[0m \u001b[0msklearn\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmodel_selection\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mtrain_test_split\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      2\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 3\u001b[0;31m \u001b[0mX_train\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mX_test\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my_train\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my_test\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mtrain_test_split\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtest_size\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m0.25\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mrandom_state\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m42\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
            "\u001b[0;31mNameError\u001b[0m: name 'X' is not defined"
          ]
        }
      ],
      "source": [
        "from sklearn.model_selection import train_test_split\n",
        "\n",
        "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=42)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "5738adad"
      },
      "source": [
        "## Train model\n",
        "\n",
        "### Subtask:\n",
        "Choose and train a suitable model on the training data.\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "193762cc"
      },
      "source": [
        "**Reasoning**:\n",
        "Import the Logistic Regression model, instantiate it, and fit it to the training data.\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 176
        },
        "id": "928a8d5f",
        "outputId": "801b31d9-a97a-4bd8-84a4-1ebcb178fe5f"
      },
      "outputs": [
        {
          "output_type": "error",
          "ename": "NameError",
          "evalue": "name 'X_train' is not defined",
          "traceback": [
            "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
            "\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)",
            "\u001b[0;32m/tmp/ipython-input-2958220566.py\u001b[0m in \u001b[0;36m<cell line: 0>\u001b[0;34m()\u001b[0m\n\u001b[1;32m      2\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      3\u001b[0m \u001b[0mmodel\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mLogisticRegression\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mrandom_state\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m42\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmax_iter\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m1000\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 4\u001b[0;31m \u001b[0mmodel\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfit\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX_train\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my_train\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
            "\u001b[0;31mNameError\u001b[0m: name 'X_train' is not defined"
          ]
        }
      ],
      "source": [
        "from sklearn.linear_model import LogisticRegression\n",
        "\n",
        "model = LogisticRegression(random_state=42, max_iter=1000)\n",
        "model.fit(X_train, y_train)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "2addc265"
      },
      "source": [
        "## Evaluate model\n",
        "\n",
        "### Subtask:\n",
        "Evaluate the trained model on the testing data using appropriate metrics.\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "e71605a9"
      },
      "source": [
        "**Reasoning**:\n",
        "Evaluate the trained model using accuracy and classification report.\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 211
        },
        "id": "93dd5381",
        "outputId": "f72322c9-c772-4163-d621-dddb33c3380f"
      },
      "outputs": [
        {
          "output_type": "error",
          "ename": "NameError",
          "evalue": "name 'model' is not defined",
          "traceback": [
            "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
            "\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)",
            "\u001b[0;32m/tmp/ipython-input-920568064.py\u001b[0m in \u001b[0;36m<cell line: 0>\u001b[0;34m()\u001b[0m\n\u001b[1;32m      2\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      3\u001b[0m \u001b[0;31m# Make predictions on test data\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 4\u001b[0;31m \u001b[0my_pred\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mmodel\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpredict\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX_test\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      5\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      6\u001b[0m \u001b[0;31m# Calculate accuracy\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;31mNameError\u001b[0m: name 'model' is not defined"
          ]
        }
      ],
      "source": [
        "from sklearn.metrics import accuracy_score, classification_report\n",
        "\n",
        "# Make predictions on test data\n",
        "y_pred = model.predict(X_test)\n",
        "\n",
        "# Calculate accuracy\n",
        "accuracy = accuracy_score(y_test, y_pred) * 100  # Convert to percentage\n",
        "\n",
        "# Generate classification report\n",
        "report = classification_report(y_test, y_pred)\n",
        "\n",
        "# Print results\n",
        "print(f\"Accuracy: {accuracy:.2f}%\")\n",
        "print(\"Classification Report:\")\n",
        "print(report)\n",
        "\n",
        "\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "226007d1"
      },
      "source": [
        "## Summary:\n",
        "\n",
        "### Data Analysis Key Findings\n",
        "\n",
        "*   The dataset from \"/content/diabetes.csv\" was successfully loaded and inspected, revealing columns such as 'Pregnancies', 'Glucose', 'BloodPressure', 'SkinThickness', 'Insulin', 'BMI', 'DiabetesPedigreeFunction', 'Age', and 'Outcome'.\n",
        "*   The dataset was split into features (\\`X\\`) and target (\\`y\\`), with 'Outcome' being the target variable.\n",
        "*   The data was further split into training (75%) and testing (25%) sets using a random state of 42.\n",
        "*   A Logistic Regression model was chosen and trained on the training data (\\`X_train\\` and \\`y_train\\`) with \\`max_iter=1000\\` and \\`random_state=42\\`.\n",
        "*   The trained model achieved an accuracy of approximately 72.4% on the test dataset.\n",
        "*   The classification report showed that the model performed better in predicting class 0 (precision 0.79, recall 0.77, f1-score 0.78) compared to class 1 (precision 0.61, recall 0.64, f1-score 0.62).\n",
        "\n",
        "### Insights or Next Steps\n",
        "\n",
        "*   The model shows reasonable performance but there is room for improvement, particularly in predicting class 1.\n",
        "*   Further steps could involve exploring different machine learning models, hyperparameter tuning, or feature engineering to enhance the model's predictive capability for the minority class.\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "aa340d9f"
      },
      "source": [
        "# Task\n",
        "Increase the accuracy of the diabetes prediction model using the dataset at \"/content/diabetes.csv\"."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "c8f0260c"
      },
      "source": [
        "## Explore different models\n",
        "\n",
        "### Subtask:\n",
        "Train and evaluate other classification models such as RandomForestClassifier, GradientBoostingClassifier, or Support Vector Machine to see if they yield better accuracy than Logistic Regression.\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "83e711a3"
      },
      "source": [
        "**Reasoning**:\n",
        "Train and evaluate RandomForestClassifier and GradientBoostingClassifier models as instructed.\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "d204e4e6",
        "outputId": "a726cedb-a021-4c3b-b3b8-9f1ed472dfb4"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "RandomForestClassifier Results:\n",
            "Accuracy: 0.734375\n",
            "Classification Report:\n",
            "              precision    recall  f1-score   support\n",
            "\n",
            "           0       0.80      0.78      0.79       123\n",
            "           1       0.62      0.65      0.64        69\n",
            "\n",
            "    accuracy                           0.73       192\n",
            "   macro avg       0.71      0.72      0.71       192\n",
            "weighted avg       0.74      0.73      0.74       192\n",
            "\n",
            "\n",
            "GradientBoostingClassifier Results:\n",
            "Accuracy: 0.7395833333333334\n",
            "Classification Report:\n",
            "              precision    recall  f1-score   support\n",
            "\n",
            "           0       0.82      0.76      0.79       123\n",
            "           1       0.62      0.70      0.66        69\n",
            "\n",
            "    accuracy                           0.74       192\n",
            "   macro avg       0.72      0.73      0.72       192\n",
            "weighted avg       0.75      0.74      0.74       192\n",
            "\n"
          ]
        }
      ],
      "source": [
        "from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier\n",
        "from sklearn.metrics import accuracy_score, classification_report\n",
        "\n",
        "# RandomForestClassifier\n",
        "rf_model = RandomForestClassifier(random_state=42)\n",
        "rf_model.fit(X_train, y_train)\n",
        "y_pred_rf = rf_model.predict(X_test)\n",
        "accuracy_rf = accuracy_score(y_test, y_pred_rf)\n",
        "report_rf = classification_report(y_test, y_pred_rf)\n",
        "\n",
        "print(\"RandomForestClassifier Results:\")\n",
        "print(f\"Accuracy: {accuracy_rf}\")\n",
        "print(\"Classification Report:\")\n",
        "print(report_rf)\n",
        "\n",
        "# GradientBoostingClassifier\n",
        "gb_model = GradientBoostingClassifier(random_state=42)\n",
        "gb_model.fit(X_train, y_train)\n",
        "y_pred_gb = gb_model.predict(X_test)\n",
        "accuracy_gb = accuracy_score(y_test, y_pred_gb)\n",
        "report_gb = classification_report(y_test, y_pred_gb)\n",
        "\n",
        "print(\"\\nGradientBoostingClassifier Results:\")\n",
        "print(f\"Accuracy: {accuracy_gb}\")\n",
        "print(\"Classification Report:\")\n",
        "print(report_gb)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "3722faad"
      },
      "source": [
        "## Hyperparameter tuning\n",
        "\n",
        "### Subtask:\n",
        "For the best performing model, tune its hyperparameters using techniques like GridSearchCV or RandomizedSearchCV to find the optimal set of parameters that maximizes accuracy.\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "43bbb178"
      },
      "source": [
        "**Reasoning**:\n",
        "Based on the previous step, the GradientBoostingClassifier had a slightly higher accuracy (0.740) compared to the RandomForestClassifier (0.734). Therefore, I will tune the hyperparameters of the GradientBoostingClassifier using GridSearchCV. I will define a parameter grid, instantiate GridSearchCV, fit it to the training data, and then get the best parameters and score.\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "b0e0b5a4",
        "outputId": "f31fce41-d0ff-4d67-d4ba-f6843bb1b049"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Best Hyperparameters: {'learning_rate': 0.01, 'max_depth': 5, 'min_samples_split': 4, 'n_estimators': 300}\n",
            "Best Cross-Validation Accuracy: 0.7794902548725637\n"
          ]
        }
      ],
      "source": [
        "from sklearn.model_selection import GridSearchCV\n",
        "\n",
        "# Define the parameter grid for GradientBoostingClassifier\n",
        "param_grid = {\n",
        "    'n_estimators': [100, 200, 300],\n",
        "    'learning_rate': [0.01, 0.05, 0.1],\n",
        "    'max_depth': [3, 4, 5],\n",
        "    'min_samples_split': [2, 3, 4]\n",
        "}\n",
        "\n",
        "# Instantiate GridSearchCV\n",
        "grid_search = GridSearchCV(estimator=gb_model, param_grid=param_grid, scoring='accuracy', cv=5, n_jobs=-1)\n",
        "\n",
        "# Fit GridSearchCV to the training data\n",
        "grid_search.fit(X_train, y_train)\n",
        "\n",
        "# Get the best hyperparameters and the best score\n",
        "best_params = grid_search.best_params_\n",
        "best_score = grid_search.best_score_\n",
        "\n",
        "print(f\"Best Hyperparameters: {best_params}\")\n",
        "print(f\"Best Cross-Validation Accuracy: {best_score}\")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "2094f7c0"
      },
      "source": [
        "**Reasoning**:\n",
        "I have found the best hyperparameters for the GradientBoostingClassifier using GridSearchCV. The next step is to evaluate the model with the best hyperparameters on the test set.\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "d08d01d0",
        "outputId": "ae000fe6-da9c-459c-89f8-e7c77c93f3ca"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Tuned GradientBoostingClassifier Results on Test Set:\n",
            "Accuracy: 0.7447916666666666\n",
            "Classification Report:\n",
            "              precision    recall  f1-score   support\n",
            "\n",
            "           0       0.81      0.78      0.80       123\n",
            "           1       0.64      0.68      0.66        69\n",
            "\n",
            "    accuracy                           0.74       192\n",
            "   macro avg       0.72      0.73      0.73       192\n",
            "weighted avg       0.75      0.74      0.75       192\n",
            "\n"
          ]
        }
      ],
      "source": [
        "# Evaluate the best model on the test data\n",
        "best_gb_model = grid_search.best_estimator_\n",
        "y_pred_tuned_gb = best_gb_model.predict(X_test)\n",
        "accuracy_tuned_gb = accuracy_score(y_test, y_pred_tuned_gb)\n",
        "report_tuned_gb = classification_report(y_test, y_pred_tuned_gb)\n",
        "\n",
        "print(\"Tuned GradientBoostingClassifier Results on Test Set:\")\n",
        "print(f\"Accuracy: {accuracy_tuned_gb}\")\n",
        "print(\"Classification Report:\")\n",
        "print(report_tuned_gb)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "3f788364"
      },
      "source": [
        "## Feature engineering (optional)\n",
        "\n",
        "### Subtask:\n",
        "Given that the accuracy improvement after hyperparameter tuning was marginal, explore creating new features or transforming existing ones to potentially further enhance the model's predictive capability.\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "8133e7a8"
      },
      "source": [
        "**Reasoning**:\n",
        "Create new features by considering interactions and transformations, then separate features and target and split the data.\n",
        "\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "6a60a8ef"
      },
      "source": [
        "## Evaluate tuned model\n",
        "\n",
        "### Subtask:\n",
        "Evaluate the performance of the tuned model on the testing data using appropriate metrics and compare it to the previous results.\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "247e73ef"
      },
      "source": [
        "**Reasoning**:\n",
        "Instantiate, train, predict, and evaluate the Gradient Boosting model with the best hyperparameters on the data with engineered features, then print the accuracy and classification report for comparison.\n",
        "\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "b78b43eb"
      },
      "source": [
        "## Summary:\n",
        "\n",
        "### Data Analysis Key Findings\n",
        "\n",
        "*   The untuned Gradient Boosting Classifier achieved an accuracy of approximately 0.740, which was slightly better than the untuned Random Forest Classifier (0.734).\n",
        "*   Hyperparameter tuning of the Gradient Boosting Classifier using GridSearchCV resulted in a best cross-validation accuracy of approximately 0.779, and an accuracy of about 0.745 on the test set (without feature engineering).\n",
        "*   The tuned Gradient Boosting model with the addition of engineered features (Glucose\\_BMI, Age\\_Glucose, BMI\\_sq, Glucose\\_sq, High\\_Glucose\\_BMI) achieved the highest accuracy of approximately 0.755 on the test set.\n",
        "*   Feature engineering and hyperparameter tuning progressively improved the model's test set accuracy compared to the initial models.\n",
        "\n",
        "### Insights or Next Steps\n",
        "\n",
        "*   The engineered features contributed to a modest improvement in model performance. Further feature engineering based on domain knowledge could potentially yield additional gains.\n",
        "*   While accuracy improved, the classification report shows an imbalance in performance between the two classes (non-diabetic vs. diabetic). Future work should focus on improving the model's ability to predict the positive class (diabetic) using techniques like handling imbalanced data or exploring different evaluation metrics like AUC-ROC.\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "4778f0e8"
      },
      "source": [
        "## Explore different models (continued)\n",
        "\n",
        "### Subtask:\n",
        "Train and evaluate a Support Vector Machine (SVM) model."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "a00c4919"
      },
      "source": [
        "**Reasoning**:\n",
        "Import the Support Vector Machine model, instantiate it, and train and evaluate it."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "163b78b7",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "876a6bc9-727e-4ca8-f34c-48a85f7b9463"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Support Vector Machine Results:\n",
            "Accuracy: 0.7291666666666666\n",
            "Classification Report:\n",
            "              precision    recall  f1-score   support\n",
            "\n",
            "           0       0.75      0.86      0.80       123\n",
            "           1       0.67      0.49      0.57        69\n",
            "\n",
            "    accuracy                           0.73       192\n",
            "   macro avg       0.71      0.68      0.68       192\n",
            "weighted avg       0.72      0.73      0.72       192\n",
            "\n"
          ]
        }
      ],
      "source": [
        "from sklearn.svm import SVC\n",
        "from sklearn.metrics import accuracy_score, classification_report\n",
        "\n",
        "# Support Vector Machine\n",
        "svm_model = SVC(random_state=42)\n",
        "svm_model.fit(X_train, y_train)\n",
        "y_pred_svm = svm_model.predict(X_test)\n",
        "accuracy_svm = accuracy_score(y_test, y_pred_svm)\n",
        "report_svm = classification_report(y_test, y_pred_svm)\n",
        "\n",
        "print(\"Support Vector Machine Results:\")\n",
        "print(f\"Accuracy: {accuracy_svm}\")\n",
        "print(\"Classification Report:\")\n",
        "print(report_svm)"
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "# New Section"
      ],
      "metadata": {
        "id": "dRM1Dh1XBNyv"
      }
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "c5f1755b"
      },
      "source": [
        "## Load data\n",
        "\n",
        "### Subtask:\n",
        "Load the dataset from the provided CSV file into a pandas DataFrame."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "267f3d63"
      },
      "source": [
        "**Reasoning**:\n",
        "Import the pandas library, read the CSV file into a DataFrame, and display the first few rows."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 206
        },
        "id": "9e1ce1f8",
        "outputId": "a593d9ec-160f-4bca-80ca-6b32854bdb70"
      },
      "source": [
        "import pandas as pd\n",
        "\n",
        "df = pd.read_csv(\"/content/diabetes.csv\")\n",
        "display(df.head())"
      ],
      "execution_count": null,
      "outputs": [
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "   Pregnancies  Glucose  BloodPressure  SkinThickness  Insulin   BMI  \\\n",
              "0            6      148             72             35        0  33.6   \n",
              "1            1       85             66             29        0  26.6   \n",
              "2            8      183             64              0        0  23.3   \n",
              "3            1       89             66             23       94  28.1   \n",
              "4            0      137             40             35      168  43.1   \n",
              "\n",
              "   DiabetesPedigreeFunction  Age  Outcome  \n",
              "0                     0.627   50        1  \n",
              "1                     0.351   31        0  \n",
              "2                     0.672   32        1  \n",
              "3                     0.167   21        0  \n",
              "4                     2.288   33        1  "
            ],
            "text/html": [
              "\n",
              "  <div id=\"df-8ccd3a2b-c831-406e-b122-06c25548c369\" class=\"colab-df-container\">\n",
              "    <div>\n",
              "<style scoped>\n",
              "    .dataframe tbody tr th:only-of-type {\n",
              "        vertical-align: middle;\n",
              "    }\n",
              "\n",
              "    .dataframe tbody tr th {\n",
              "        vertical-align: top;\n",
              "    }\n",
              "\n",
              "    .dataframe thead th {\n",
              "        text-align: right;\n",
              "    }\n",
              "</style>\n",
              "<table border=\"1\" class=\"dataframe\">\n",
              "  <thead>\n",
              "    <tr style=\"text-align: right;\">\n",
              "      <th></th>\n",
              "      <th>Pregnancies</th>\n",
              "      <th>Glucose</th>\n",
              "      <th>BloodPressure</th>\n",
              "      <th>SkinThickness</th>\n",
              "      <th>Insulin</th>\n",
              "      <th>BMI</th>\n",
              "      <th>DiabetesPedigreeFunction</th>\n",
              "      <th>Age</th>\n",
              "      <th>Outcome</th>\n",
              "    </tr>\n",
              "  </thead>\n",
              "  <tbody>\n",
              "    <tr>\n",
              "      <th>0</th>\n",
              "      <td>6</td>\n",
              "      <td>148</td>\n",
              "      <td>72</td>\n",
              "      <td>35</td>\n",
              "      <td>0</td>\n",
              "      <td>33.6</td>\n",
              "      <td>0.627</td>\n",
              "      <td>50</td>\n",
              "      <td>1</td>\n",
              "    </tr>\n",
              "    <tr>\n",
              "      <th>1</th>\n",
              "      <td>1</td>\n",
              "      <td>85</td>\n",
              "      <td>66</td>\n",
              "      <td>29</td>\n",
              "      <td>0</td>\n",
              "      <td>26.6</td>\n",
              "      <td>0.351</td>\n",
              "      <td>31</td>\n",
              "      <td>0</td>\n",
              "    </tr>\n",
              "    <tr>\n",
              "      <th>2</th>\n",
              "      <td>8</td>\n",
              "      <td>183</td>\n",
              "      <td>64</td>\n",
              "      <td>0</td>\n",
              "      <td>0</td>\n",
              "      <td>23.3</td>\n",
              "      <td>0.672</td>\n",
              "      <td>32</td>\n",
              "      <td>1</td>\n",
              "    </tr>\n",
              "    <tr>\n",
              "      <th>3</th>\n",
              "      <td>1</td>\n",
              "      <td>89</td>\n",
              "      <td>66</td>\n",
              "      <td>23</td>\n",
              "      <td>94</td>\n",
              "      <td>28.1</td>\n",
              "      <td>0.167</td>\n",
              "      <td>21</td>\n",
              "      <td>0</td>\n",
              "    </tr>\n",
              "    <tr>\n",
              "      <th>4</th>\n",
              "      <td>0</td>\n",
              "      <td>137</td>\n",
              "      <td>40</td>\n",
              "      <td>35</td>\n",
              "      <td>168</td>\n",
              "      <td>43.1</td>\n",
              "      <td>2.288</td>\n",
              "      <td>33</td>\n",
              "      <td>1</td>\n",
              "    </tr>\n",
              "  </tbody>\n",
              "</table>\n",
              "</div>\n",
              "    <div class=\"colab-df-buttons\">\n",
              "\n",
              "  <div class=\"colab-df-container\">\n",
              "    <button class=\"colab-df-convert\" onclick=\"convertToInteractive('df-8ccd3a2b-c831-406e-b122-06c25548c369')\"\n",
              "            title=\"Convert this dataframe to an interactive table.\"\n",
              "            style=\"display:none;\">\n",
              "\n",
              "  <svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\" viewBox=\"0 -960 960 960\">\n",
              "    <path d=\"M120-120v-720h720v720H120Zm60-500h600v-160H180v160Zm220 220h160v-160H400v160Zm0 220h160v-160H400v160ZM180-400h160v-160H180v160Zm440 0h160v-160H620v160ZM180-180h160v-160H180v160Zm440 0h160v-160H620v160Z\"/>\n",
              "  </svg>\n",
              "    </button>\n",
              "\n",
              "  <style>\n",
              "    .colab-df-container {\n",
              "      display:flex;\n",
              "      gap: 12px;\n",
              "    }\n",
              "\n",
              "    .colab-df-convert {\n",
              "      background-color: #E8F0FE;\n",
              "      border: none;\n",
              "      border-radius: 50%;\n",
              "      cursor: pointer;\n",
              "      display: none;\n",
              "      fill: #1967D2;\n",
              "      height: 32px;\n",
              "      padding: 0 0 0 0;\n",
              "      width: 32px;\n",
              "    }\n",
              "\n",
              "    .colab-df-convert:hover {\n",
              "      background-color: #E2EBFA;\n",
              "      box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15);\n",
              "      fill: #174EA6;\n",
              "    }\n",
              "\n",
              "    .colab-df-buttons div {\n",
              "      margin-bottom: 4px;\n",
              "    }\n",
              "\n",
              "    [theme=dark] .colab-df-convert {\n",
              "      background-color: #3B4455;\n",
              "      fill: #D2E3FC;\n",
              "    }\n",
              "\n",
              "    [theme=dark] .colab-df-convert:hover {\n",
              "      background-color: #434B5C;\n",
              "      box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15);\n",
              "      filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3));\n",
              "      fill: #FFFFFF;\n",
              "    }\n",
              "  </style>\n",
              "\n",
              "    <script>\n",
              "      const buttonEl =\n",
              "        document.querySelector('#df-8ccd3a2b-c831-406e-b122-06c25548c369 button.colab-df-convert');\n",
              "      buttonEl.style.display =\n",
              "        google.colab.kernel.accessAllowed ? 'block' : 'none';\n",
              "\n",
              "      async function convertToInteractive(key) {\n",
              "        const element = document.querySelector('#df-8ccd3a2b-c831-406e-b122-06c25548c369');\n",
              "        const dataTable =\n",
              "          await google.colab.kernel.invokeFunction('convertToInteractive',\n",
              "                                                    [key], {});\n",
              "        if (!dataTable) return;\n",
              "\n",
              "        const docLinkHtml = 'Like what you see? Visit the ' +\n",
              "          '<a target=\"_blank\" href=https://colab.research.google.com/notebooks/data_table.ipynb>data table notebook</a>'\n",
              "          + ' to learn more about interactive tables.';\n",
              "        element.innerHTML = '';\n",
              "        dataTable['output_type'] = 'display_data';\n",
              "        await google.colab.output.renderOutput(dataTable, element);\n",
              "        const docLink = document.createElement('div');\n",
              "        docLink.innerHTML = docLinkHtml;\n",
              "        element.appendChild(docLink);\n",
              "      }\n",
              "    </script>\n",
              "  </div>\n",
              "\n",
              "\n",
              "    <div id=\"df-5767cd12-62b7-4bb5-b57c-437e85e4ede7\">\n",
              "      <button class=\"colab-df-quickchart\" onclick=\"quickchart('df-5767cd12-62b7-4bb5-b57c-437e85e4ede7')\"\n",
              "                title=\"Suggest charts\"\n",
              "                style=\"display:none;\">\n",
              "\n",
              "<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\"viewBox=\"0 0 24 24\"\n",
              "     width=\"24px\">\n",
              "    <g>\n",
              "        <path d=\"M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z\"/>\n",
              "    </g>\n",
              "</svg>\n",
              "      </button>\n",
              "\n",
              "<style>\n",
              "  .colab-df-quickchart {\n",
              "      --bg-color: #E8F0FE;\n",
              "      --fill-color: #1967D2;\n",
              "      --hover-bg-color: #E2EBFA;\n",
              "      --hover-fill-color: #174EA6;\n",
              "      --disabled-fill-color: #AAA;\n",
              "      --disabled-bg-color: #DDD;\n",
              "  }\n",
              "\n",
              "  [theme=dark] .colab-df-quickchart {\n",
              "      --bg-color: #3B4455;\n",
              "      --fill-color: #D2E3FC;\n",
              "      --hover-bg-color: #434B5C;\n",
              "      --hover-fill-color: #FFFFFF;\n",
              "      --disabled-bg-color: #3B4455;\n",
              "      --disabled-fill-color: #666;\n",
              "  }\n",
              "\n",
              "  .colab-df-quickchart {\n",
              "    background-color: var(--bg-color);\n",
              "    border: none;\n",
              "    border-radius: 50%;\n",
              "    cursor: pointer;\n",
              "    display: none;\n",
              "    fill: var(--fill-color);\n",
              "    height: 32px;\n",
              "    padding: 0;\n",
              "    width: 32px;\n",
              "  }\n",
              "\n",
              "  .colab-df-quickchart:hover {\n",
              "    background-color: var(--hover-bg-color);\n",
              "    box-shadow: 0 1px 2px rgba(60, 64, 67, 0.3), 0 1px 3px 1px rgba(60, 64, 67, 0.15);\n",
              "    fill: var(--button-hover-fill-color);\n",
              "  }\n",
              "\n",
              "  .colab-df-quickchart-complete:disabled,\n",
              "  .colab-df-quickchart-complete:disabled:hover {\n",
              "    background-color: var(--disabled-bg-color);\n",
              "    fill: var(--disabled-fill-color);\n",
              "    box-shadow: none;\n",
              "  }\n",
              "\n",
              "  .colab-df-spinner {\n",
              "    border: 2px solid var(--fill-color);\n",
              "    border-color: transparent;\n",
              "    border-bottom-color: var(--fill-color);\n",
              "    animation:\n",
              "      spin 1s steps(1) infinite;\n",
              "  }\n",
              "\n",
              "  @keyframes spin {\n",
              "    0% {\n",
              "      border-color: transparent;\n",
              "      border-bottom-color: var(--fill-color);\n",
              "      border-left-color: var(--fill-color);\n",
              "    }\n",
              "    20% {\n",
              "      border-color: transparent;\n",
              "      border-left-color: var(--fill-color);\n",
              "      border-top-color: var(--fill-color);\n",
              "    }\n",
              "    30% {\n",
              "      border-color: transparent;\n",
              "      border-left-color: var(--fill-color);\n",
              "      border-top-color: var(--fill-color);\n",
              "      border-right-color: var(--fill-color);\n",
              "    }\n",
              "    40% {\n",
              "      border-color: transparent;\n",
              "      border-right-color: var(--fill-color);\n",
              "      border-top-color: var(--fill-color);\n",
              "    }\n",
              "    60% {\n",
              "      border-color: transparent;\n",
              "      border-right-color: var(--fill-color);\n",
              "    }\n",
              "    80% {\n",
              "      border-color: transparent;\n",
              "      border-right-color: var(--fill-color);\n",
              "      border-bottom-color: var(--fill-color);\n",
              "    }\n",
              "    90% {\n",
              "      border-color: transparent;\n",
              "      border-bottom-color: var(--fill-color);\n",
              "    }\n",
              "  }\n",
              "</style>\n",
              "\n",
              "      <script>\n",
              "        async function quickchart(key) {\n",
              "          const quickchartButtonEl =\n",
              "            document.querySelector('#' + key + ' button');\n",
              "          quickchartButtonEl.disabled = true;  // To prevent multiple clicks.\n",
              "          quickchartButtonEl.classList.add('colab-df-spinner');\n",
              "          try {\n",
              "            const charts = await google.colab.kernel.invokeFunction(\n",
              "                'suggestCharts', [key], {});\n",
              "          } catch (error) {\n",
              "            console.error('Error during call to suggestCharts:', error);\n",
              "          }\n",
              "          quickchartButtonEl.classList.remove('colab-df-spinner');\n",
              "          quickchartButtonEl.classList.add('colab-df-quickchart-complete');\n",
              "        }\n",
              "        (() => {\n",
              "          let quickchartButtonEl =\n",
              "            document.querySelector('#df-5767cd12-62b7-4bb5-b57c-437e85e4ede7 button');\n",
              "          quickchartButtonEl.style.display =\n",
              "            google.colab.kernel.accessAllowed ? 'block' : 'none';\n",
              "        })();\n",
              "      </script>\n",
              "    </div>\n",
              "\n",
              "    </div>\n",
              "  </div>\n"
            ],
            "application/vnd.google.colaboratory.intrinsic+json": {
              "type": "dataframe",
              "summary": "{\n  \"name\": \"display(df\",\n  \"rows\": 5,\n  \"fields\": [\n    {\n      \"column\": \"Pregnancies\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 3,\n        \"min\": 0,\n        \"max\": 8,\n        \"num_unique_values\": 4,\n        \"samples\": [\n          1,\n          0,\n          6\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"Glucose\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 41,\n        \"min\": 85,\n        \"max\": 183,\n        \"num_unique_values\": 5,\n        \"samples\": [\n          85,\n          137,\n          183\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"BloodPressure\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 12,\n        \"min\": 40,\n        \"max\": 72,\n        \"num_unique_values\": 4,\n        \"samples\": [\n          66,\n          40,\n          72\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"SkinThickness\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 14,\n        \"min\": 0,\n        \"max\": 35,\n        \"num_unique_values\": 4,\n        \"samples\": [\n          29,\n          23,\n          35\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"Insulin\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 76,\n        \"min\": 0,\n        \"max\": 168,\n        \"num_unique_values\": 3,\n        \"samples\": [\n          0,\n          94,\n          168\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"BMI\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 7.749387072536769,\n        \"min\": 23.3,\n        \"max\": 43.1,\n        \"num_unique_values\": 5,\n        \"samples\": [\n          26.6,\n          43.1,\n          23.3\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"DiabetesPedigreeFunction\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 0.8456568452983751,\n        \"min\": 0.167,\n        \"max\": 2.288,\n        \"num_unique_values\": 5,\n        \"samples\": [\n          0.351,\n          2.288,\n          0.672\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"Age\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 10,\n        \"min\": 21,\n        \"max\": 50,\n        \"num_unique_values\": 5,\n        \"samples\": [\n          31,\n          33,\n          32\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"Outcome\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 0,\n        \"min\": 0,\n        \"max\": 1,\n        \"num_unique_values\": 2,\n        \"samples\": [\n          0,\n          1\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    }\n  ]\n}"
            }
          },
          "metadata": {}
        }
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "b175cd77"
      },
      "source": [
        "## Prepare data\n",
        "\n",
        "### Subtask:\n",
        "Separate the features (independent variables) and the target (dependent variable) for training the model."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "7029fe1c"
      },
      "source": [
        "**Reasoning**:\n",
        "Separate the features (independent variables) into X and the target (dependent variable) into y."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "36e9aad0"
      },
      "source": [
        "X = df.drop('Outcome', axis=1)\n",
        "y = df['Outcome']"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "d9e47254"
      },
      "source": [
        "## Split data\n",
        "\n",
        "### Subtask:\n",
        "Split the dataset into training and testing sets to evaluate the model's performance on unseen data."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "b05e7194"
      },
      "source": [
        "**Reasoning**:\n",
        "Split the data into training and testing sets as instructed."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "147a5c3b"
      },
      "source": [
        "from sklearn.model_selection import train_test_split\n",
        "\n",
        "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=42)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "fac300f7"
      },
      "source": [
        "## Handle data imbalance\n",
        "\n",
        "### Subtask:\n",
        "Apply techniques like SMOTE to address the class imbalance in the dataset."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "c1beebbd"
      },
      "source": [
        "**Reasoning**:\n",
        "Apply SMOTE to the training data to address class imbalance and display the class distribution before and after SMOTE."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "9044718d",
        "outputId": "fef5a3c6-277a-40ec-aa93-6d24912c03f5"
      },
      "source": [
        "from imblearn.over_sampling import SMOTE\n",
        "\n",
        "# Instantiate SMOTE\n",
        "smote = SMOTE(random_state=42)\n",
        "\n",
        "# Apply SMOTE to the training data\n",
        "X_train_resampled, y_train_resampled = smote.fit_resample(X_train, y_train)\n",
        "\n",
        "# Print class distribution before and after SMOTE\n",
        "print(\"Original training data class distribution:\")\n",
        "print(y_train.value_counts())\n",
        "print(\"\\nResampled training data class distribution:\")\n",
        "print(y_train_resampled.value_counts())"
      ],
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Original training data class distribution:\n",
            "Outcome\n",
            "0    377\n",
            "1    199\n",
            "Name: count, dtype: int64\n",
            "\n",
            "Resampled training data class distribution:\n",
            "Outcome\n",
            "1    377\n",
            "0    377\n",
            "Name: count, dtype: int64\n"
          ]
        }
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "df153bee"
      },
      "source": [
        "## Explore different models (continued)\n",
        "\n",
        "### Subtask:\n",
        "Train and evaluate a Support Vector Machine (SVM) model on the balanced data."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "90fba518"
      },
      "source": [
        "**Reasoning**:\n",
        "Import the Support Vector Machine model, instantiate it, and train and evaluate it on the balanced data."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "ab9123b0",
        "outputId": "cee2b8e8-9c66-4125-b2ce-18cbd078ac0e"
      },
      "source": [
        "import pandas as pd\n",
        "from sklearn.model_selection import train_test_split, GridSearchCV\n",
        "from sklearn.preprocessing import StandardScaler\n",
        "from sklearn.feature_selection import RFE\n",
        "from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier, StackingClassifier\n",
        "from sklearn.svm import SVC\n",
        "from sklearn.metrics import accuracy_score, classification_report\n",
        "from imblearn.over_sampling import SMOTE\n",
        "\n",
        "# Load dataset\n",
        "df = pd.read_csv(\"diabetes.csv\")\n",
        "\n",
        "# Features and target\n",
        "X = df.drop('Outcome', axis=1)\n",
        "y = df['Outcome']\n",
        "\n",
        "# Split data\n",
        "X_train, X_test, y_train, y_test = train_test_split(\n",
        "    X, y, test_size=0.2, random_state=42, stratify=y\n",
        ")\n",
        "\n",
        "# Balance data using SMOTE\n",
        "smote = SMOTE(random_state=42)\n",
        "X_train_resampled, y_train_resampled = smote.fit_resample(X_train, y_train)\n",
        "\n",
        "# Scale features\n",
        "scaler = StandardScaler()\n",
        "X_train_scaled = scaler.fit_transform(X_train_resampled)\n",
        "X_test_scaled = scaler.transform(X_test)\n",
        "\n",
        "# === Step 1: Feature Selection using RFE ===\n",
        "svm_base = SVC(kernel='linear')\n",
        "rfe = RFE(estimator=svm_base, n_features_to_select=6)\n",
        "rfe.fit(X_train_scaled, y_train_resampled)\n",
        "\n",
        "X_train_selected = rfe.transform(X_train_scaled)\n",
        "X_test_selected = rfe.transform(X_test_scaled)\n",
        "\n",
        "# === Step 2: Ensemble & Stacking ===\n",
        "# Base models\n",
        "rf = RandomForestClassifier(n_estimators=300, random_state=42)\n",
        "gb = GradientBoostingClassifier(n_estimators=300, learning_rate=0.05, random_state=42)\n",
        "svm_final = SVC(kernel='rbf', C=10, gamma='scale', probability=True, random_state=42)\n",
        "\n",
        "# Stacking ensemble (meta model is SVM)\n",
        "stack_model = StackingClassifier(\n",
        "    estimators=[('rf', rf), ('gb', gb)],\n",
        "    final_estimator=svm_final,\n",
        "    passthrough=True\n",
        ")\n",
        "\n",
        "# Train\n",
        "stack_model.fit(X_train_selected, y_train_resampled)\n",
        "\n",
        "# Predict\n",
        "y_pred = stack_model.predict(X_test_selected)\n",
        "\n",
        "# Evaluate\n",
        "accuracy = accuracy_score(y_test, y_pred)\n",
        "report = classification_report(y_test, y_pred)\n",
        "\n",
        "print(\" High-Accuracy Stacking Model Results \")\n",
        "print(f\"Accuracy: {accuracy * 100:.2f}%\")\n",
        "print(\"Classification Report:\")\n",
        "print(report)\n"
      ],
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            " High-Accuracy Stacking Model Results \n",
            "Accuracy: 76.62%\n",
            "Classification Report:\n",
            "              precision    recall  f1-score   support\n",
            "\n",
            "           0       0.83      0.80      0.82       100\n",
            "           1       0.66      0.70      0.68        54\n",
            "\n",
            "    accuracy                           0.77       154\n",
            "   macro avg       0.74      0.75      0.75       154\n",
            "weighted avg       0.77      0.77      0.77       154\n",
            "\n"
          ]
        }
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "0353bd01"
      },
      "source": [
        "## Hyperparameter tuning on balanced data\n",
        "\n",
        "### Subtask:\n",
        "Perform hyperparameter tuning for the best performing model(s) on the balanced data (`X_train_resampled`, `y_train_resampled`) using GridSearchCV or RandomizedSearchCV."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "6c72c14c"
      },
      "source": [
        "**Reasoning**:\n",
        "Based on the previous step, the RandomForestClassifier had the highest accuracy (0.766) on the balanced data. Therefore, I will tune the hyperparameters of the RandomForestClassifier using GridSearchCV. I will define a parameter grid, instantiate GridSearchCV, fit it to the resampled training data, and then get the best parameters and score."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "d6bb9106",
        "outputId": "294706bd-c6f8-469e-ed6e-f9512fc75712"
      },
      "source": [
        "from sklearn.model_selection import GridSearchCV\n",
        "from sklearn.ensemble import RandomForestClassifier\n",
        "\n",
        "# Define the parameter grid for RandomForestClassifier\n",
        "param_grid_rf = {\n",
        "    'n_estimators': [100, 200, 300],\n",
        "    'max_depth': [10, 20, 30],\n",
        "    'min_samples_split': [2, 5, 10],\n",
        "    'min_samples_leaf': [1, 2, 4]\n",
        "}\n",
        "\n",
        "# Instantiate RandomForestClassifier\n",
        "rf_model_tune = RandomForestClassifier(random_state=42)\n",
        "\n",
        "# Instantiate GridSearchCV\n",
        "grid_search_rf = GridSearchCV(estimator=rf_model_tune, param_grid=param_grid_rf, scoring='accuracy', cv=5, n_jobs=-1)\n",
        "\n",
        "# Fit GridSearchCV to the resampled training data\n",
        "grid_search_rf.fit(X_train_resampled, y_train_resampled)\n",
        "\n",
        "# Get the best hyperparameters and the best score\n",
        "best_params_rf = grid_search_rf.best_params_\n",
        "best_score_rf = grid_search_rf.best_score_\n",
        "\n",
        "print(f\"Best Hyperparameters for RandomForestClassifier: {best_params_rf}\")\n",
        "print(f\"Best Cross-Validation Accuracy for RandomForestClassifier: {best_score_rf}\")"
      ],
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Best Hyperparameters for RandomForestClassifier: {'max_depth': 20, 'min_samples_leaf': 2, 'min_samples_split': 2, 'n_estimators': 100}\n",
            "Best Cross-Validation Accuracy for RandomForestClassifier: 0.8409006622516557\n"
          ]
        }
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "4a6aee8c"
      },
      "source": [
        "## Evaluate tuned model on test set\n",
        "\n",
        "### Subtask:\n",
        "Evaluate the tuned RandomForestClassifier model on the test set (`X_test`, `y_test`) using appropriate metrics."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "908427ef"
      },
      "source": [
        "**Reasoning**:\n",
        "Evaluate the tuned RandomForestClassifier model (using the best hyperparameters found by GridSearchCV) on the test set and display the accuracy and classification report."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "e4ae8607",
        "outputId": "f01e11ed-cb1b-4db5-b098-8b72f5bbe31d"
      },
      "source": [
        "from sklearn.metrics import accuracy_score, classification_report\n",
        "\n",
        "# Get the best model from GridSearchCV\n",
        "best_rf_model = grid_search_rf.best_estimator_\n",
        "\n",
        "# Predict on the test set\n",
        "y_pred_tuned_rf = best_rf_model.predict(X_test)\n",
        "\n",
        "# Evaluate the tuned model\n",
        "accuracy_tuned_rf = accuracy_score(y_test, y_pred_tuned_rf)\n",
        "report_tuned_rf = classification_report(y_test, y_pred_tuned_rf)\n",
        "\n",
        "print(\"Tuned RandomForestClassifier Results on Test Set:\")\n",
        "print(f\"Accuracy: {accuracy_tuned_rf}\")\n",
        "print(\"Classification Report:\")\n",
        "print(report_tuned_rf)"
      ],
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Tuned RandomForestClassifier Results on Test Set:\n",
            "Accuracy: 0.7604166666666666\n",
            "Classification Report:\n",
            "              precision    recall  f1-score   support\n",
            "\n",
            "           0       0.85      0.76      0.80       123\n",
            "           1       0.64      0.77      0.70        69\n",
            "\n",
            "    accuracy                           0.76       192\n",
            "   macro avg       0.75      0.76      0.75       192\n",
            "weighted avg       0.78      0.76      0.76       192\n",
            "\n"
          ]
        }
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "114053c6"
      },
      "source": [
        "## Load data\n",
        "\n",
        "### Subtask:\n",
        "Load the dataset from the provided CSV file into a pandas DataFrame."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "532aba86"
      },
      "source": [
        "**Reasoning**:\n",
        "Import the pandas library, read the CSV file into a DataFrame, and display the first few rows."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 206
        },
        "id": "709190f5",
        "outputId": "587638a0-733a-4a65-a34c-e94acbfc9951"
      },
      "source": [
        "import pandas as pd\n",
        "\n",
        "df = pd.read_csv(\"/content/diabetes.csv\")\n",
        "display(df.head())"
      ],
      "execution_count": null,
      "outputs": [
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "   Pregnancies  Glucose  BloodPressure  SkinThickness  Insulin   BMI  \\\n",
              "0            6      148             72             35        0  33.6   \n",
              "1            1       85             66             29        0  26.6   \n",
              "2            8      183             64              0        0  23.3   \n",
              "3            1       89             66             23       94  28.1   \n",
              "4            0      137             40             35      168  43.1   \n",
              "\n",
              "   DiabetesPedigreeFunction  Age  Outcome  \n",
              "0                     0.627   50        1  \n",
              "1                     0.351   31        0  \n",
              "2                     0.672   32        1  \n",
              "3                     0.167   21        0  \n",
              "4                     2.288   33        1  "
            ],
            "text/html": [
              "\n",
              "  <div id=\"df-b214ca07-2f2c-4eab-b9b3-00a1ea5aa8e4\" class=\"colab-df-container\">\n",
              "    <div>\n",
              "<style scoped>\n",
              "    .dataframe tbody tr th:only-of-type {\n",
              "        vertical-align: middle;\n",
              "    }\n",
              "\n",
              "    .dataframe tbody tr th {\n",
              "        vertical-align: top;\n",
              "    }\n",
              "\n",
              "    .dataframe thead th {\n",
              "        text-align: right;\n",
              "    }\n",
              "</style>\n",
              "<table border=\"1\" class=\"dataframe\">\n",
              "  <thead>\n",
              "    <tr style=\"text-align: right;\">\n",
              "      <th></th>\n",
              "      <th>Pregnancies</th>\n",
              "      <th>Glucose</th>\n",
              "      <th>BloodPressure</th>\n",
              "      <th>SkinThickness</th>\n",
              "      <th>Insulin</th>\n",
              "      <th>BMI</th>\n",
              "      <th>DiabetesPedigreeFunction</th>\n",
              "      <th>Age</th>\n",
              "      <th>Outcome</th>\n",
              "    </tr>\n",
              "  </thead>\n",
              "  <tbody>\n",
              "    <tr>\n",
              "      <th>0</th>\n",
              "      <td>6</td>\n",
              "      <td>148</td>\n",
              "      <td>72</td>\n",
              "      <td>35</td>\n",
              "      <td>0</td>\n",
              "      <td>33.6</td>\n",
              "      <td>0.627</td>\n",
              "      <td>50</td>\n",
              "      <td>1</td>\n",
              "    </tr>\n",
              "    <tr>\n",
              "      <th>1</th>\n",
              "      <td>1</td>\n",
              "      <td>85</td>\n",
              "      <td>66</td>\n",
              "      <td>29</td>\n",
              "      <td>0</td>\n",
              "      <td>26.6</td>\n",
              "      <td>0.351</td>\n",
              "      <td>31</td>\n",
              "      <td>0</td>\n",
              "    </tr>\n",
              "    <tr>\n",
              "      <th>2</th>\n",
              "      <td>8</td>\n",
              "      <td>183</td>\n",
              "      <td>64</td>\n",
              "      <td>0</td>\n",
              "      <td>0</td>\n",
              "      <td>23.3</td>\n",
              "      <td>0.672</td>\n",
              "      <td>32</td>\n",
              "      <td>1</td>\n",
              "    </tr>\n",
              "    <tr>\n",
              "      <th>3</th>\n",
              "      <td>1</td>\n",
              "      <td>89</td>\n",
              "      <td>66</td>\n",
              "      <td>23</td>\n",
              "      <td>94</td>\n",
              "      <td>28.1</td>\n",
              "      <td>0.167</td>\n",
              "      <td>21</td>\n",
              "      <td>0</td>\n",
              "    </tr>\n",
              "    <tr>\n",
              "      <th>4</th>\n",
              "      <td>0</td>\n",
              "      <td>137</td>\n",
              "      <td>40</td>\n",
              "      <td>35</td>\n",
              "      <td>168</td>\n",
              "      <td>43.1</td>\n",
              "      <td>2.288</td>\n",
              "      <td>33</td>\n",
              "      <td>1</td>\n",
              "    </tr>\n",
              "  </tbody>\n",
              "</table>\n",
              "</div>\n",
              "    <div class=\"colab-df-buttons\">\n",
              "\n",
              "  <div class=\"colab-df-container\">\n",
              "    <button class=\"colab-df-convert\" onclick=\"convertToInteractive('df-b214ca07-2f2c-4eab-b9b3-00a1ea5aa8e4')\"\n",
              "            title=\"Convert this dataframe to an interactive table.\"\n",
              "            style=\"display:none;\">\n",
              "\n",
              "  <svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\" viewBox=\"0 -960 960 960\">\n",
              "    <path d=\"M120-120v-720h720v720H120Zm60-500h600v-160H180v160Zm220 220h160v-160H400v160Zm0 220h160v-160H400v160ZM180-400h160v-160H180v160Zm440 0h160v-160H620v160ZM180-180h160v-160H180v160Zm440 0h160v-160H620v160Z\"/>\n",
              "  </svg>\n",
              "    </button>\n",
              "\n",
              "  <style>\n",
              "    .colab-df-container {\n",
              "      display:flex;\n",
              "      gap: 12px;\n",
              "    }\n",
              "\n",
              "    .colab-df-convert {\n",
              "      background-color: #E8F0FE;\n",
              "      border: none;\n",
              "      border-radius: 50%;\n",
              "      cursor: pointer;\n",
              "      display: none;\n",
              "      fill: #1967D2;\n",
              "      height: 32px;\n",
              "      padding: 0 0 0 0;\n",
              "      width: 32px;\n",
              "    }\n",
              "\n",
              "    .colab-df-convert:hover {\n",
              "      background-color: #E2EBFA;\n",
              "      box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15);\n",
              "      fill: #174EA6;\n",
              "    }\n",
              "\n",
              "    .colab-df-buttons div {\n",
              "      margin-bottom: 4px;\n",
              "    }\n",
              "\n",
              "    [theme=dark] .colab-df-convert {\n",
              "      background-color: #3B4455;\n",
              "      fill: #D2E3FC;\n",
              "    }\n",
              "\n",
              "    [theme=dark] .colab-df-convert:hover {\n",
              "      background-color: #434B5C;\n",
              "      box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15);\n",
              "      filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3));\n",
              "      fill: #FFFFFF;\n",
              "    }\n",
              "  </style>\n",
              "\n",
              "    <script>\n",
              "      const buttonEl =\n",
              "        document.querySelector('#df-b214ca07-2f2c-4eab-b9b3-00a1ea5aa8e4 button.colab-df-convert');\n",
              "      buttonEl.style.display =\n",
              "        google.colab.kernel.accessAllowed ? 'block' : 'none';\n",
              "\n",
              "      async function convertToInteractive(key) {\n",
              "        const element = document.querySelector('#df-b214ca07-2f2c-4eab-b9b3-00a1ea5aa8e4');\n",
              "        const dataTable =\n",
              "          await google.colab.kernel.invokeFunction('convertToInteractive',\n",
              "                                                    [key], {});\n",
              "        if (!dataTable) return;\n",
              "\n",
              "        const docLinkHtml = 'Like what you see? Visit the ' +\n",
              "          '<a target=\"_blank\" href=https://colab.research.google.com/notebooks/data_table.ipynb>data table notebook</a>'\n",
              "          + ' to learn more about interactive tables.';\n",
              "        element.innerHTML = '';\n",
              "        dataTable['output_type'] = 'display_data';\n",
              "        await google.colab.output.renderOutput(dataTable, element);\n",
              "        const docLink = document.createElement('div');\n",
              "        docLink.innerHTML = docLinkHtml;\n",
              "        element.appendChild(docLink);\n",
              "      }\n",
              "    </script>\n",
              "  </div>\n",
              "\n",
              "\n",
              "    <div id=\"df-442d0c86-6b1c-41b5-9f58-19c2b2d5326f\">\n",
              "      <button class=\"colab-df-quickchart\" onclick=\"quickchart('df-442d0c86-6b1c-41b5-9f58-19c2b2d5326f')\"\n",
              "                title=\"Suggest charts\"\n",
              "                style=\"display:none;\">\n",
              "\n",
              "<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\"viewBox=\"0 0 24 24\"\n",
              "     width=\"24px\">\n",
              "    <g>\n",
              "        <path d=\"M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z\"/>\n",
              "    </g>\n",
              "</svg>\n",
              "      </button>\n",
              "\n",
              "<style>\n",
              "  .colab-df-quickchart {\n",
              "      --bg-color: #E8F0FE;\n",
              "      --fill-color: #1967D2;\n",
              "      --hover-bg-color: #E2EBFA;\n",
              "      --hover-fill-color: #174EA6;\n",
              "      --disabled-fill-color: #AAA;\n",
              "      --disabled-bg-color: #DDD;\n",
              "  }\n",
              "\n",
              "  [theme=dark] .colab-df-quickchart {\n",
              "      --bg-color: #3B4455;\n",
              "      --fill-color: #D2E3FC;\n",
              "      --hover-bg-color: #434B5C;\n",
              "      --hover-fill-color: #FFFFFF;\n",
              "      --disabled-bg-color: #3B4455;\n",
              "      --disabled-fill-color: #666;\n",
              "  }\n",
              "\n",
              "  .colab-df-quickchart {\n",
              "    background-color: var(--bg-color);\n",
              "    border: none;\n",
              "    border-radius: 50%;\n",
              "    cursor: pointer;\n",
              "    display: none;\n",
              "    fill: var(--fill-color);\n",
              "    height: 32px;\n",
              "    padding: 0;\n",
              "    width: 32px;\n",
              "  }\n",
              "\n",
              "  .colab-df-quickchart:hover {\n",
              "    background-color: var(--hover-bg-color);\n",
              "    box-shadow: 0 1px 2px rgba(60, 64, 67, 0.3), 0 1px 3px 1px rgba(60, 64, 67, 0.15);\n",
              "    fill: var(--button-hover-fill-color);\n",
              "  }\n",
              "\n",
              "  .colab-df-quickchart-complete:disabled,\n",
              "  .colab-df-quickchart-complete:disabled:hover {\n",
              "    background-color: var(--disabled-bg-color);\n",
              "    fill: var(--disabled-fill-color);\n",
              "    box-shadow: none;\n",
              "  }\n",
              "\n",
              "  .colab-df-spinner {\n",
              "    border: 2px solid var(--fill-color);\n",
              "    border-color: transparent;\n",
              "    border-bottom-color: var(--fill-color);\n",
              "    animation:\n",
              "      spin 1s steps(1) infinite;\n",
              "  }\n",
              "\n",
              "  @keyframes spin {\n",
              "    0% {\n",
              "      border-color: transparent;\n",
              "      border-bottom-color: var(--fill-color);\n",
              "      border-left-color: var(--fill-color);\n",
              "    }\n",
              "    20% {\n",
              "      border-color: transparent;\n",
              "      border-left-color: var(--fill-color);\n",
              "      border-top-color: var(--fill-color);\n",
              "    }\n",
              "    30% {\n",
              "      border-color: transparent;\n",
              "      border-left-color: var(--fill-color);\n",
              "      border-top-color: var(--fill-color);\n",
              "      border-right-color: var(--fill-color);\n",
              "    }\n",
              "    40% {\n",
              "      border-color: transparent;\n",
              "      border-right-color: var(--fill-color);\n",
              "      border-top-color: var(--fill-color);\n",
              "    }\n",
              "    60% {\n",
              "      border-color: transparent;\n",
              "      border-right-color: var(--fill-color);\n",
              "    }\n",
              "    80% {\n",
              "      border-color: transparent;\n",
              "      border-right-color: var(--fill-color);\n",
              "      border-bottom-color: var(--fill-color);\n",
              "    }\n",
              "    90% {\n",
              "      border-color: transparent;\n",
              "      border-bottom-color: var(--fill-color);\n",
              "    }\n",
              "  }\n",
              "</style>\n",
              "\n",
              "      <script>\n",
              "        async function quickchart(key) {\n",
              "          const quickchartButtonEl =\n",
              "            document.querySelector('#' + key + ' button');\n",
              "          quickchartButtonEl.disabled = true;  // To prevent multiple clicks.\n",
              "          quickchartButtonEl.classList.add('colab-df-spinner');\n",
              "          try {\n",
              "            const charts = await google.colab.kernel.invokeFunction(\n",
              "                'suggestCharts', [key], {});\n",
              "          } catch (error) {\n",
              "            console.error('Error during call to suggestCharts:', error);\n",
              "          }\n",
              "          quickchartButtonEl.classList.remove('colab-df-spinner');\n",
              "          quickchartButtonEl.classList.add('colab-df-quickchart-complete');\n",
              "        }\n",
              "        (() => {\n",
              "          let quickchartButtonEl =\n",
              "            document.querySelector('#df-442d0c86-6b1c-41b5-9f58-19c2b2d5326f button');\n",
              "          quickchartButtonEl.style.display =\n",
              "            google.colab.kernel.accessAllowed ? 'block' : 'none';\n",
              "        })();\n",
              "      </script>\n",
              "    </div>\n",
              "\n",
              "    </div>\n",
              "  </div>\n"
            ],
            "application/vnd.google.colaboratory.intrinsic+json": {
              "type": "dataframe",
              "summary": "{\n  \"name\": \"display(df\",\n  \"rows\": 5,\n  \"fields\": [\n    {\n      \"column\": \"Pregnancies\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 3,\n        \"min\": 0,\n        \"max\": 8,\n        \"num_unique_values\": 4,\n        \"samples\": [\n          1,\n          0,\n          6\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"Glucose\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 41,\n        \"min\": 85,\n        \"max\": 183,\n        \"num_unique_values\": 5,\n        \"samples\": [\n          85,\n          137,\n          183\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"BloodPressure\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 12,\n        \"min\": 40,\n        \"max\": 72,\n        \"num_unique_values\": 4,\n        \"samples\": [\n          66,\n          40,\n          72\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"SkinThickness\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 14,\n        \"min\": 0,\n        \"max\": 35,\n        \"num_unique_values\": 4,\n        \"samples\": [\n          29,\n          23,\n          35\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"Insulin\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 76,\n        \"min\": 0,\n        \"max\": 168,\n        \"num_unique_values\": 3,\n        \"samples\": [\n          0,\n          94,\n          168\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"BMI\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 7.749387072536769,\n        \"min\": 23.3,\n        \"max\": 43.1,\n        \"num_unique_values\": 5,\n        \"samples\": [\n          26.6,\n          43.1,\n          23.3\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"DiabetesPedigreeFunction\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 0.8456568452983751,\n        \"min\": 0.167,\n        \"max\": 2.288,\n        \"num_unique_values\": 5,\n        \"samples\": [\n          0.351,\n          2.288,\n          0.672\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"Age\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 10,\n        \"min\": 21,\n        \"max\": 50,\n        \"num_unique_values\": 5,\n        \"samples\": [\n          31,\n          33,\n          32\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"Outcome\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 0,\n        \"min\": 0,\n        \"max\": 1,\n        \"num_unique_values\": 2,\n        \"samples\": [\n          0,\n          1\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    }\n  ]\n}"
            }
          },
          "metadata": {}
        }
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "bca0a64c"
      },
      "source": [
        "## Prepare data\n",
        "\n",
        "### Subtask:\n",
        "Separate the features (independent variables) and the target (dependent variable) for training the model."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "861262fb"
      },
      "source": [
        "**Reasoning**:\n",
        "Separate the features (independent variables) into X and the target (dependent variable) into y."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "62c129ea"
      },
      "source": [
        "X = df.drop('Outcome', axis=1)\n",
        "y = df['Outcome']"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "449e7c6b"
      },
      "source": [
        "## Split data\n",
        "\n",
        "### Subtask:\n",
        "Split the dataset into training and testing sets to evaluate the model's performance on unseen data."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "ee216a34"
      },
      "source": [
        "**Reasoning**:\n",
        "Split the data into training and testing sets as instructed."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "1f88bc06"
      },
      "source": [
        "from sklearn.model_selection import train_test_split\n",
        "\n",
        "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=42)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "67e08770"
      },
      "source": [
        "## Handle data imbalance\n",
        "\n",
        "### Subtask:\n",
        "Apply techniques like SMOTE to address the class imbalance in the dataset."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "be2716df"
      },
      "source": [
        "**Reasoning**:\n",
        "Apply SMOTE to the training data to address class imbalance and display the class distribution before and after SMOTE."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "2da8fcfe",
        "outputId": "3f127f46-5f7d-42f3-86e7-47b22f86295f"
      },
      "source": [
        "from imblearn.over_sampling import SMOTE\n",
        "\n",
        "# Instantiate SMOTE\n",
        "smote = SMOTE(random_state=42)\n",
        "\n",
        "# Apply SMOTE to the training data\n",
        "X_train_resampled, y_train_resampled = smote.fit_resample(X_train, y_train)\n",
        "\n",
        "# Print class distribution before and after SMOTE\n",
        "print(\"Original training data class distribution:\")\n",
        "print(y_train.value_counts())\n",
        "print(\"\\nResampled training data class distribution:\")\n",
        "print(y_train_resampled.value_counts())"
      ],
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Original training data class distribution:\n",
            "Outcome\n",
            "0    377\n",
            "1    199\n",
            "Name: count, dtype: int64\n",
            "\n",
            "Resampled training data class distribution:\n",
            "Outcome\n",
            "1    377\n",
            "0    377\n",
            "Name: count, dtype: int64\n"
          ]
        }
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "e52239f9"
      },
      "source": [
        "## Explore different models (continued)\n",
        "\n",
        "### Subtask:\n",
        "Train and evaluate a Support Vector Machine (SVM) model on the balanced data."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "b356aee8"
      },
      "source": [
        "**Reasoning**:\n",
        "Import the Support Vector Machine model, instantiate it, and train and evaluate it on the balanced data."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "023cfe1b",
        "outputId": "6227065a-c2d6-4da1-9823-a73f1659d7bf"
      },
      "source": [
        "from sklearn.svm import SVC\n",
        "from sklearn.metrics import accuracy_score, classification_report\n",
        "\n",
        "# Support Vector Machine\n",
        "# Train the SVM model on the resampled training data\n",
        "svm_model = SVC(random_state=42)\n",
        "svm_model.fit(X_train_resampled, y_train_resampled) # Use resampled data\n",
        "\n",
        "# Predict on the original test set\n",
        "y_pred_svm = svm_model.predict(X_test)\n",
        "accuracy_svm = accuracy_score(y_test, y_pred_svm)\n",
        "report_svm = classification_report(y_test, y_pred_svm)\n",
        "\n",
        "print(\"Support Vector Machine Results with Balanced Data:\")\n",
        "print(f\"Accuracy: {accuracy_svm}\")\n",
        "print(\"Classification Report:\")\n",
        "print(report_svm)"
      ],
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Support Vector Machine Results with Balanced Data:\n",
            "Accuracy: 0.671875\n",
            "Classification Report:\n",
            "              precision    recall  f1-score   support\n",
            "\n",
            "           0       0.78      0.67      0.72       123\n",
            "           1       0.53      0.67      0.59        69\n",
            "\n",
            "    accuracy                           0.67       192\n",
            "   macro avg       0.66      0.67      0.66       192\n",
            "weighted avg       0.69      0.67      0.68       192\n",
            "\n"
          ]
        }
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "637473ab"
      },
      "source": [
        "## Handle data imbalance\n",
        "\n",
        "### Subtask:\n",
        "Apply techniques like SMOTE to address the class imbalance in the dataset."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "896d1c6a"
      },
      "source": [
        "**Reasoning**:\n",
        "Apply SMOTE to the training data to address class imbalance and display the class distribution before and after SMOTE."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "c6b066e1",
        "outputId": "0494e126-af9a-41f6-d470-576fd57ef99e"
      },
      "source": [
        "from imblearn.over_sampling import SMOTE\n",
        "\n",
        "# Instantiate SMOTE\n",
        "smote = SMOTE(random_state=42)\n",
        "\n",
        "# Apply SMOTE to the training data\n",
        "X_train_resampled, y_train_resampled = smote.fit_resample(X_train, y_train)\n",
        "\n",
        "# Print class distribution before and after SMOTE\n",
        "print(\"Original training data class distribution:\")\n",
        "print(y_train.value_counts())\n",
        "print(\"\\nResampled training data class distribution:\")\n",
        "print(y_train_resampled.value_counts())"
      ],
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Original training data class distribution:\n",
            "Outcome\n",
            "0    377\n",
            "1    199\n",
            "Name: count, dtype: int64\n",
            "\n",
            "Resampled training data class distribution:\n",
            "Outcome\n",
            "1    377\n",
            "0    377\n",
            "Name: count, dtype: int64\n"
          ]
        }
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "3e728711"
      },
      "source": [
        "## Load data\n",
        "\n",
        "### Subtask:\n",
        "Load the dataset from the provided CSV file into a pandas DataFrame."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "3af289db"
      },
      "source": [
        "**Reasoning**:\n",
        "Import the pandas library, read the CSV file into a DataFrame, and display the first few rows."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 206
        },
        "id": "86f5ee9b",
        "outputId": "e0f0e287-10cf-413e-d701-1cbc9ec4a724"
      },
      "source": [
        "import pandas as pd\n",
        "\n",
        "df = pd.read_csv(\"/content/diabetes.csv\")\n",
        "display(df.head())"
      ],
      "execution_count": null,
      "outputs": [
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "   Pregnancies  Glucose  BloodPressure  SkinThickness  Insulin   BMI  \\\n",
              "0            6      148             72             35        0  33.6   \n",
              "1            1       85             66             29        0  26.6   \n",
              "2            8      183             64              0        0  23.3   \n",
              "3            1       89             66             23       94  28.1   \n",
              "4            0      137             40             35      168  43.1   \n",
              "\n",
              "   DiabetesPedigreeFunction  Age  Outcome  \n",
              "0                     0.627   50        1  \n",
              "1                     0.351   31        0  \n",
              "2                     0.672   32        1  \n",
              "3                     0.167   21        0  \n",
              "4                     2.288   33        1  "
            ],
            "text/html": [
              "\n",
              "  <div id=\"df-21e2a40a-be4e-4f1e-a906-4ef9ce011bb6\" class=\"colab-df-container\">\n",
              "    <div>\n",
              "<style scoped>\n",
              "    .dataframe tbody tr th:only-of-type {\n",
              "        vertical-align: middle;\n",
              "    }\n",
              "\n",
              "    .dataframe tbody tr th {\n",
              "        vertical-align: top;\n",
              "    }\n",
              "\n",
              "    .dataframe thead th {\n",
              "        text-align: right;\n",
              "    }\n",
              "</style>\n",
              "<table border=\"1\" class=\"dataframe\">\n",
              "  <thead>\n",
              "    <tr style=\"text-align: right;\">\n",
              "      <th></th>\n",
              "      <th>Pregnancies</th>\n",
              "      <th>Glucose</th>\n",
              "      <th>BloodPressure</th>\n",
              "      <th>SkinThickness</th>\n",
              "      <th>Insulin</th>\n",
              "      <th>BMI</th>\n",
              "      <th>DiabetesPedigreeFunction</th>\n",
              "      <th>Age</th>\n",
              "      <th>Outcome</th>\n",
              "    </tr>\n",
              "  </thead>\n",
              "  <tbody>\n",
              "    <tr>\n",
              "      <th>0</th>\n",
              "      <td>6</td>\n",
              "      <td>148</td>\n",
              "      <td>72</td>\n",
              "      <td>35</td>\n",
              "      <td>0</td>\n",
              "      <td>33.6</td>\n",
              "      <td>0.627</td>\n",
              "      <td>50</td>\n",
              "      <td>1</td>\n",
              "    </tr>\n",
              "    <tr>\n",
              "      <th>1</th>\n",
              "      <td>1</td>\n",
              "      <td>85</td>\n",
              "      <td>66</td>\n",
              "      <td>29</td>\n",
              "      <td>0</td>\n",
              "      <td>26.6</td>\n",
              "      <td>0.351</td>\n",
              "      <td>31</td>\n",
              "      <td>0</td>\n",
              "    </tr>\n",
              "    <tr>\n",
              "      <th>2</th>\n",
              "      <td>8</td>\n",
              "      <td>183</td>\n",
              "      <td>64</td>\n",
              "      <td>0</td>\n",
              "      <td>0</td>\n",
              "      <td>23.3</td>\n",
              "      <td>0.672</td>\n",
              "      <td>32</td>\n",
              "      <td>1</td>\n",
              "    </tr>\n",
              "    <tr>\n",
              "      <th>3</th>\n",
              "      <td>1</td>\n",
              "      <td>89</td>\n",
              "      <td>66</td>\n",
              "      <td>23</td>\n",
              "      <td>94</td>\n",
              "      <td>28.1</td>\n",
              "      <td>0.167</td>\n",
              "      <td>21</td>\n",
              "      <td>0</td>\n",
              "    </tr>\n",
              "    <tr>\n",
              "      <th>4</th>\n",
              "      <td>0</td>\n",
              "      <td>137</td>\n",
              "      <td>40</td>\n",
              "      <td>35</td>\n",
              "      <td>168</td>\n",
              "      <td>43.1</td>\n",
              "      <td>2.288</td>\n",
              "      <td>33</td>\n",
              "      <td>1</td>\n",
              "    </tr>\n",
              "  </tbody>\n",
              "</table>\n",
              "</div>\n",
              "    <div class=\"colab-df-buttons\">\n",
              "\n",
              "  <div class=\"colab-df-container\">\n",
              "    <button class=\"colab-df-convert\" onclick=\"convertToInteractive('df-21e2a40a-be4e-4f1e-a906-4ef9ce011bb6')\"\n",
              "            title=\"Convert this dataframe to an interactive table.\"\n",
              "            style=\"display:none;\">\n",
              "\n",
              "  <svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\" viewBox=\"0 -960 960 960\">\n",
              "    <path d=\"M120-120v-720h720v720H120Zm60-500h600v-160H180v160Zm220 220h160v-160H400v160Zm0 220h160v-160H400v160ZM180-400h160v-160H180v160Zm440 0h160v-160H620v160ZM180-180h160v-160H180v160Zm440 0h160v-160H620v160Z\"/>\n",
              "  </svg>\n",
              "    </button>\n",
              "\n",
              "  <style>\n",
              "    .colab-df-container {\n",
              "      display:flex;\n",
              "      gap: 12px;\n",
              "    }\n",
              "\n",
              "    .colab-df-convert {\n",
              "      background-color: #E8F0FE;\n",
              "      border: none;\n",
              "      border-radius: 50%;\n",
              "      cursor: pointer;\n",
              "      display: none;\n",
              "      fill: #1967D2;\n",
              "      height: 32px;\n",
              "      padding: 0 0 0 0;\n",
              "      width: 32px;\n",
              "    }\n",
              "\n",
              "    .colab-df-convert:hover {\n",
              "      background-color: #E2EBFA;\n",
              "      box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15);\n",
              "      fill: #174EA6;\n",
              "    }\n",
              "\n",
              "    .colab-df-buttons div {\n",
              "      margin-bottom: 4px;\n",
              "    }\n",
              "\n",
              "    [theme=dark] .colab-df-convert {\n",
              "      background-color: #3B4455;\n",
              "      fill: #D2E3FC;\n",
              "    }\n",
              "\n",
              "    [theme=dark] .colab-df-convert:hover {\n",
              "      background-color: #434B5C;\n",
              "      box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15);\n",
              "      filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3));\n",
              "      fill: #FFFFFF;\n",
              "    }\n",
              "  </style>\n",
              "\n",
              "    <script>\n",
              "      const buttonEl =\n",
              "        document.querySelector('#df-21e2a40a-be4e-4f1e-a906-4ef9ce011bb6 button.colab-df-convert');\n",
              "      buttonEl.style.display =\n",
              "        google.colab.kernel.accessAllowed ? 'block' : 'none';\n",
              "\n",
              "      async function convertToInteractive(key) {\n",
              "        const element = document.querySelector('#df-21e2a40a-be4e-4f1e-a906-4ef9ce011bb6');\n",
              "        const dataTable =\n",
              "          await google.colab.kernel.invokeFunction('convertToInteractive',\n",
              "                                                    [key], {});\n",
              "        if (!dataTable) return;\n",
              "\n",
              "        const docLinkHtml = 'Like what you see? Visit the ' +\n",
              "          '<a target=\"_blank\" href=https://colab.research.google.com/notebooks/data_table.ipynb>data table notebook</a>'\n",
              "          + ' to learn more about interactive tables.';\n",
              "        element.innerHTML = '';\n",
              "        dataTable['output_type'] = 'display_data';\n",
              "        await google.colab.output.renderOutput(dataTable, element);\n",
              "        const docLink = document.createElement('div');\n",
              "        docLink.innerHTML = docLinkHtml;\n",
              "        element.appendChild(docLink);\n",
              "      }\n",
              "    </script>\n",
              "  </div>\n",
              "\n",
              "\n",
              "    <div id=\"df-8867bc8b-0183-44d6-be37-841081694625\">\n",
              "      <button class=\"colab-df-quickchart\" onclick=\"quickchart('df-8867bc8b-0183-44d6-be37-841081694625')\"\n",
              "                title=\"Suggest charts\"\n",
              "                style=\"display:none;\">\n",
              "\n",
              "<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\"viewBox=\"0 0 24 24\"\n",
              "     width=\"24px\">\n",
              "    <g>\n",
              "        <path d=\"M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z\"/>\n",
              "    </g>\n",
              "</svg>\n",
              "      </button>\n",
              "\n",
              "<style>\n",
              "  .colab-df-quickchart {\n",
              "      --bg-color: #E8F0FE;\n",
              "      --fill-color: #1967D2;\n",
              "      --hover-bg-color: #E2EBFA;\n",
              "      --hover-fill-color: #174EA6;\n",
              "      --disabled-fill-color: #AAA;\n",
              "      --disabled-bg-color: #DDD;\n",
              "  }\n",
              "\n",
              "  [theme=dark] .colab-df-quickchart {\n",
              "      --bg-color: #3B4455;\n",
              "      --fill-color: #D2E3FC;\n",
              "      --hover-bg-color: #434B5C;\n",
              "      --hover-fill-color: #FFFFFF;\n",
              "      --disabled-bg-color: #3B4455;\n",
              "      --disabled-fill-color: #666;\n",
              "  }\n",
              "\n",
              "  .colab-df-quickchart {\n",
              "    background-color: var(--bg-color);\n",
              "    border: none;\n",
              "    border-radius: 50%;\n",
              "    cursor: pointer;\n",
              "    display: none;\n",
              "    fill: var(--fill-color);\n",
              "    height: 32px;\n",
              "    padding: 0;\n",
              "    width: 32px;\n",
              "  }\n",
              "\n",
              "  .colab-df-quickchart:hover {\n",
              "    background-color: var(--hover-bg-color);\n",
              "    box-shadow: 0 1px 2px rgba(60, 64, 67, 0.3), 0 1px 3px 1px rgba(60, 64, 67, 0.15);\n",
              "    fill: var(--button-hover-fill-color);\n",
              "  }\n",
              "\n",
              "  .colab-df-quickchart-complete:disabled,\n",
              "  .colab-df-quickchart-complete:disabled:hover {\n",
              "    background-color: var(--disabled-bg-color);\n",
              "    fill: var(--disabled-fill-color);\n",
              "    box-shadow: none;\n",
              "  }\n",
              "\n",
              "  .colab-df-spinner {\n",
              "    border: 2px solid var(--fill-color);\n",
              "    border-color: transparent;\n",
              "    border-bottom-color: var(--fill-color);\n",
              "    animation:\n",
              "      spin 1s steps(1) infinite;\n",
              "  }\n",
              "\n",
              "  @keyframes spin {\n",
              "    0% {\n",
              "      border-color: transparent;\n",
              "      border-bottom-color: var(--fill-color);\n",
              "      border-left-color: var(--fill-color);\n",
              "    }\n",
              "    20% {\n",
              "      border-color: transparent;\n",
              "      border-left-color: var(--fill-color);\n",
              "      border-top-color: var(--fill-color);\n",
              "    }\n",
              "    30% {\n",
              "      border-color: transparent;\n",
              "      border-left-color: var(--fill-color);\n",
              "      border-top-color: var(--fill-color);\n",
              "      border-right-color: var(--fill-color);\n",
              "    }\n",
              "    40% {\n",
              "      border-color: transparent;\n",
              "      border-right-color: var(--fill-color);\n",
              "      border-top-color: var(--fill-color);\n",
              "    }\n",
              "    60% {\n",
              "      border-color: transparent;\n",
              "      border-right-color: var(--fill-color);\n",
              "    }\n",
              "    80% {\n",
              "      border-color: transparent;\n",
              "      border-right-color: var(--fill-color);\n",
              "      border-bottom-color: var(--fill-color);\n",
              "    }\n",
              "    90% {\n",
              "      border-color: transparent;\n",
              "      border-bottom-color: var(--fill-color);\n",
              "    }\n",
              "  }\n",
              "</style>\n",
              "\n",
              "      <script>\n",
              "        async function quickchart(key) {\n",
              "          const quickchartButtonEl =\n",
              "            document.querySelector('#' + key + ' button');\n",
              "          quickchartButtonEl.disabled = true;  // To prevent multiple clicks.\n",
              "          quickchartButtonEl.classList.add('colab-df-spinner');\n",
              "          try {\n",
              "            const charts = await google.colab.kernel.invokeFunction(\n",
              "                'suggestCharts', [key], {});\n",
              "          } catch (error) {\n",
              "            console.error('Error during call to suggestCharts:', error);\n",
              "          }\n",
              "          quickchartButtonEl.classList.remove('colab-df-spinner');\n",
              "          quickchartButtonEl.classList.add('colab-df-quickchart-complete');\n",
              "        }\n",
              "        (() => {\n",
              "          let quickchartButtonEl =\n",
              "            document.querySelector('#df-8867bc8b-0183-44d6-be37-841081694625 button');\n",
              "          quickchartButtonEl.style.display =\n",
              "            google.colab.kernel.accessAllowed ? 'block' : 'none';\n",
              "        })();\n",
              "      </script>\n",
              "    </div>\n",
              "\n",
              "    </div>\n",
              "  </div>\n"
            ],
            "application/vnd.google.colaboratory.intrinsic+json": {
              "type": "dataframe",
              "summary": "{\n  \"name\": \"display(df\",\n  \"rows\": 5,\n  \"fields\": [\n    {\n      \"column\": \"Pregnancies\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 3,\n        \"min\": 0,\n        \"max\": 8,\n        \"num_unique_values\": 4,\n        \"samples\": [\n          1,\n          0,\n          6\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"Glucose\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 41,\n        \"min\": 85,\n        \"max\": 183,\n        \"num_unique_values\": 5,\n        \"samples\": [\n          85,\n          137,\n          183\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"BloodPressure\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 12,\n        \"min\": 40,\n        \"max\": 72,\n        \"num_unique_values\": 4,\n        \"samples\": [\n          66,\n          40,\n          72\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"SkinThickness\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 14,\n        \"min\": 0,\n        \"max\": 35,\n        \"num_unique_values\": 4,\n        \"samples\": [\n          29,\n          23,\n          35\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"Insulin\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 76,\n        \"min\": 0,\n        \"max\": 168,\n        \"num_unique_values\": 3,\n        \"samples\": [\n          0,\n          94,\n          168\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"BMI\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 7.749387072536769,\n        \"min\": 23.3,\n        \"max\": 43.1,\n        \"num_unique_values\": 5,\n        \"samples\": [\n          26.6,\n          43.1,\n          23.3\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"DiabetesPedigreeFunction\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 0.8456568452983751,\n        \"min\": 0.167,\n        \"max\": 2.288,\n        \"num_unique_values\": 5,\n        \"samples\": [\n          0.351,\n          2.288,\n          0.672\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"Age\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 10,\n        \"min\": 21,\n        \"max\": 50,\n        \"num_unique_values\": 5,\n        \"samples\": [\n          31,\n          33,\n          32\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"Outcome\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 0,\n        \"min\": 0,\n        \"max\": 1,\n        \"num_unique_values\": 2,\n        \"samples\": [\n          0,\n          1\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    }\n  ]\n}"
            }
          },
          "metadata": {}
        }
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "c4d4f654"
      },
      "source": [
        "## Prepare data\n",
        "\n",
        "### Subtask:\n",
        "Separate the features (independent variables) and the target (dependent variable) for training the model."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "b0192754"
      },
      "source": [
        "**Reasoning**:\n",
        "Separate the features (independent variables) into X and the target (dependent variable) into y."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "40c6d0dd"
      },
      "source": [
        "X = df.drop('Outcome', axis=1)\n",
        "y = df['Outcome']"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "3cc5a428"
      },
      "source": [
        "## Split data\n",
        "\n",
        "### Subtask:\n",
        "Split the dataset into training and testing sets to evaluate the model's performance on unseen data."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "d9f43ed7"
      },
      "source": [
        "**Reasoning**:\n",
        "Split the data into training and testing sets as instructed."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "9e22e3a9"
      },
      "source": [
        "from sklearn.model_selection import train_test_split\n",
        "\n",
        "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=42)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "94a27989"
      },
      "source": [
        "## Handle data imbalance\n",
        "\n",
        "### Subtask:\n",
        "Apply techniques like SMOTE to address the class imbalance in the dataset."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "60682c4e"
      },
      "source": [
        "**Reasoning**:\n",
        "Apply SMOTE to the training data to address class imbalance and display the class distribution before and after SMOTE."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "f2f59254",
        "outputId": "345fc4ee-96a0-4a9c-ab8c-70a07a7ef434"
      },
      "source": [
        "from imblearn.over_sampling import SMOTE\n",
        "\n",
        "# Instantiate SMOTE\n",
        "smote = SMOTE(random_state=42)\n",
        "\n",
        "# Apply SMOTE to the training data\n",
        "X_train_resampled, y_train_resampled = smote.fit_resample(X_train, y_train)\n",
        "\n",
        "# Print class distribution before and after SMOTE\n",
        "print(\"Original training data class distribution:\")\n",
        "print(y_train.value_counts())\n",
        "print(\"\\nResampled training data class distribution:\")\n",
        "print(y_train_resampled.value_counts())"
      ],
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Original training data class distribution:\n",
            "Outcome\n",
            "0    377\n",
            "1    199\n",
            "Name: count, dtype: int64\n",
            "\n",
            "Resampled training data class distribution:\n",
            "Outcome\n",
            "1    377\n",
            "0    377\n",
            "Name: count, dtype: int64\n"
          ]
        }
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "90eb613d"
      },
      "source": [
        "## Explore different models (continued)\n",
        "\n",
        "### Subtask:\n",
        "Train and evaluate a Support Vector Machine (SVM) model on the balanced data."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "cf79a56b"
      },
      "source": [
        "**Reasoning**:\n",
        "Import the Support Vector Machine model, instantiate it, and train and evaluate it on the balanced data."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "56f52036"
      },
      "source": [
        "## Explore different models (continued)\n",
        "\n",
        "### Subtask:\n",
        "Train and evaluate a Support Vector Machine (SVM) model on the balanced data."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "e550c689"
      },
      "source": [
        "**Reasoning**:\n",
        "Import the Support Vector Machine model, instantiate it, and train and evaluate it on the balanced data."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "2520af59",
        "outputId": "77365fec-90b8-4a01-bd07-f94fd9810e9a"
      },
      "source": [
        "from sklearn.svm import SVC\n",
        "from sklearn.metrics import accuracy_score, classification_report\n",
        "\n",
        "# Support Vector Machine\n",
        "# Train the SVM model on the resampled training data\n",
        "svm_model = SVC(random_state=42)\n",
        "svm_model.fit(X_train_resampled, y_train_resampled) # Use resampled data\n",
        "\n",
        "# Predict on the original test set\n",
        "y_pred_svm = svm_model.predict(X_test)\n",
        "accuracy_svm = accuracy_score(y_test, y_pred_svm)\n",
        "report_svm = classification_report(y_test, y_pred_svm)\n",
        "\n",
        "print(\"Support Vector Machine Results with Balanced Data:\")\n",
        "print(f\"Accuracy: {accuracy_svm}\")\n",
        "print(\"Classification Report:\")\n",
        "print(report_svm)"
      ],
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Support Vector Machine Results with Balanced Data:\n",
            "Accuracy: 0.671875\n",
            "Classification Report:\n",
            "              precision    recall  f1-score   support\n",
            "\n",
            "           0       0.78      0.67      0.72       123\n",
            "           1       0.53      0.67      0.59        69\n",
            "\n",
            "    accuracy                           0.67       192\n",
            "   macro avg       0.66      0.67      0.66       192\n",
            "weighted avg       0.69      0.67      0.68       192\n",
            "\n"
          ]
        }
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "b777881a"
      },
      "source": [
        "## Hyperparameter tuning on balanced data\n",
        "\n",
        "### Subtask:\n",
        "Perform hyperparameter tuning for the best performing model(s) on the balanced data (`X_train_resampled`, `y_train_resampled`) using GridSearchCV or RandomizedSearchCV."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "9e297f77"
      },
      "source": [
        "**Reasoning**:\n",
        "Based on the previous step, the RandomForestClassifier had the highest accuracy (0.766) on the balanced data. Therefore, I will tune the hyperparameters of the RandomForestClassifier using GridSearchCV. I will define a parameter grid, instantiate GridSearchCV, fit it to the resampled training data, and then get the best parameters and score."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "daa367bb"
      },
      "source": [
        "## Re-evaluate models with balanced data\n",
        "\n",
        "### Subtask:\n",
        "Train and evaluate the previously explored models (Logistic Regression, Random Forest, Gradient Boosting, SVM) on the balanced data (`X_train_resampled`, `y_train_resampled`)."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "3d4272e9"
      },
      "source": [
        "**Reasoning**:\n",
        "Train and evaluate the previously explored models on the balanced data as instructed."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "5f68ea3f",
        "outputId": "d9b4061a-fe86-4039-e3f5-b2fe42dc2c72"
      },
      "source": [
        "from sklearn.linear_model import LogisticRegression\n",
        "from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier\n",
        "from sklearn.svm import SVC\n",
        "from sklearn.metrics import accuracy_score, classification_report\n",
        "\n",
        "# Logistic Regression\n",
        "lr_model = LogisticRegression(random_state=42, max_iter=1000)\n",
        "lr_model.fit(X_train_resampled, y_train_resampled)\n",
        "y_pred_lr = lr_model.predict(X_test)\n",
        "accuracy_lr = accuracy_score(y_test, y_pred_lr)\n",
        "report_lr = classification_report(y_test, y_pred_lr)\n",
        "\n",
        "print(\"Logistic Regression Results with Balanced Data:\")\n",
        "print(f\"Accuracy: {accuracy_lr}\")\n",
        "print(\"Classification Report:\")\n",
        "print(report_lr)\n",
        "\n",
        "# RandomForestClassifier\n",
        "rf_model = RandomForestClassifier(random_state=42)\n",
        "rf_model.fit(X_train_resampled, y_train_resampled)\n",
        "y_pred_rf = rf_model.predict(X_test)\n",
        "accuracy_rf = accuracy_score(y_test, y_pred_rf)\n",
        "report_rf = classification_report(y_test, y_pred_rf)\n",
        "\n",
        "print(\"\\nRandomForestClassifier Results with Balanced Data:\")\n",
        "print(f\"Accuracy: {accuracy_rf}\")\n",
        "print(\"Classification Report:\")\n",
        "print(report_rf)\n",
        "\n",
        "# GradientBoostingClassifier\n",
        "gb_model = GradientBoostingClassifier(random_state=42)\n",
        "gb_model.fit(X_train_resampled, y_train_resampled)\n",
        "y_pred_gb = gb_model.predict(X_test)\n",
        "accuracy_gb = accuracy_score(y_test, y_pred_gb)\n",
        "report_gb = classification_report(y_test, y_pred_gb)\n",
        "\n",
        "print(\"\\nGradientBoostingClassifier Results with Balanced Data:\")\n",
        "print(f\"Accuracy: {accuracy_gb}\")\n",
        "print(\"Classification Report:\")\n",
        "print(report_gb)\n",
        "\n",
        "# Support Vector Machine\n",
        "svm_model = SVC(random_state=42)\n",
        "svm_model.fit(X_train_resampled, y_train_resampled)\n",
        "y_pred_svm = svm_model.predict(X_test)\n",
        "accuracy_svm = accuracy_score(y_test, y_pred_svm)\n",
        "report_svm = classification_report(y_test, y_pred_svm)\n",
        "\n",
        "print(\"\\nSupport Vector Machine Results with Balanced Data:\")\n",
        "print(f\"Accuracy: {accuracy_svm}\")\n",
        "print(\"Classification Report:\")\n",
        "print(report_svm)"
      ],
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Logistic Regression Results with Balanced Data:\n",
            "Accuracy: 0.6927083333333334\n",
            "Classification Report:\n",
            "              precision    recall  f1-score   support\n",
            "\n",
            "           0       0.81      0.68      0.74       123\n",
            "           1       0.56      0.71      0.62        69\n",
            "\n",
            "    accuracy                           0.69       192\n",
            "   macro avg       0.68      0.70      0.68       192\n",
            "weighted avg       0.72      0.69      0.70       192\n",
            "\n",
            "\n",
            "RandomForestClassifier Results with Balanced Data:\n",
            "Accuracy: 0.765625\n",
            "Classification Report:\n",
            "              precision    recall  f1-score   support\n",
            "\n",
            "           0       0.85      0.76      0.81       123\n",
            "           1       0.65      0.77      0.70        69\n",
            "\n",
            "    accuracy                           0.77       192\n",
            "   macro avg       0.75      0.77      0.75       192\n",
            "weighted avg       0.78      0.77      0.77       192\n",
            "\n",
            "\n",
            "GradientBoostingClassifier Results with Balanced Data:\n",
            "Accuracy: 0.7083333333333334\n",
            "Classification Report:\n",
            "              precision    recall  f1-score   support\n",
            "\n",
            "           0       0.83      0.68      0.75       123\n",
            "           1       0.57      0.75      0.65        69\n",
            "\n",
            "    accuracy                           0.71       192\n",
            "   macro avg       0.70      0.72      0.70       192\n",
            "weighted avg       0.74      0.71      0.71       192\n",
            "\n",
            "\n",
            "Support Vector Machine Results with Balanced Data:\n",
            "Accuracy: 0.671875\n",
            "Classification Report:\n",
            "              precision    recall  f1-score   support\n",
            "\n",
            "           0       0.78      0.67      0.72       123\n",
            "           1       0.53      0.67      0.59        69\n",
            "\n",
            "    accuracy                           0.67       192\n",
            "   macro avg       0.66      0.67      0.66       192\n",
            "weighted avg       0.69      0.67      0.68       192\n",
            "\n"
          ]
        }
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "b6692077"
      },
      "source": [
        "## Handle data imbalance\n",
        "\n",
        "### Subtask:\n",
        "Apply techniques like SMOTE to address the class imbalance in the dataset."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "1a3e008c"
      },
      "source": [
        "**Reasoning**:\n",
        "Apply SMOTE to the training data to address class imbalance and display the class distribution before and after SMOTE."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "6246d1b4",
        "outputId": "681c7038-c8e5-4222-a9e7-0591a85244d8"
      },
      "source": [
        "from imblearn.over_sampling import SMOTE\n",
        "\n",
        "# Instantiate SMOTE\n",
        "smote = SMOTE(random_state=42)\n",
        "\n",
        "# Apply SMOTE to the training data\n",
        "X_train_resampled, y_train_resampled = smote.fit_resample(X_train, y_train)\n",
        "\n",
        "# Print class distribution before and after SMOTE\n",
        "print(\"Original training data class distribution:\")\n",
        "print(y_train.value_counts())\n",
        "print(\"\\nResampled training data class distribution:\")\n",
        "print(y_train_resampled.value_counts())"
      ],
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Original training data class distribution:\n",
            "Outcome\n",
            "0    377\n",
            "1    199\n",
            "Name: count, dtype: int64\n",
            "\n",
            "Resampled training data class distribution:\n",
            "Outcome\n",
            "1    377\n",
            "0    377\n",
            "Name: count, dtype: int64\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 564
        },
        "id": "cf3f508d",
        "outputId": "2ec44158-91d5-4fce-be6b-ddd9bfe93596"
      },
      "source": [
        "from sklearn.metrics import confusion_matrix\n",
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "\n",
        "# Ensure we are using the correct test set for the diabetes data\n",
        "# Assuming X_test and y_test from the diabetes dataset split are available in the environment\n",
        "\n",
        "# Predict using the best Gradient Boosting model trained on the diabetes data with engineered features\n",
        "# Assuming 'best_gb_model' from cell 2cf106cd is available in the environment\n",
        "y_pred_final_diabetes = best_gb_model.predict(X_test)\n",
        "\n",
        "\n",
        "# Generate the confusion matrix for the predictions of the tuned Gradient Boosting model with feature engineering\n",
        "cm = confusion_matrix(y_test, y_pred_final_diabetes)\n",
        "\n",
        "# Display the confusion matrix using a heatmap\n",
        "plt.figure(figsize=(8, 6))\n",
        "sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=['0', '1'], yticklabels=['0', '1'])\n",
        "plt.xlabel('Predicted')\n",
        "plt.ylabel('Actual')\n",
        "plt.title('Confusion Matrix for Tuned Gradient Boosting Model with Feature Engineering')\n",
        "plt.show()"
      ],
      "execution_count": null,
      "outputs": [
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "<Figure size 800x600 with 2 Axes>"
            ],
            "image/png": "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ybFr+t1339WyZcsUHx+vpKQkeXp6asqUKfrhhx80a9asHLsvo6KiNGvWLPXr10/FixfXiy++KEkKDg7WhQsX1KBBA+3atUvPP/+8IiIiNHfuXHXp0kUnT560+2IjSdOnT9fFixfVo0cPWa1WBQUFOXRub9W///6rpk2bKi4uTh07dtS8efP0yiuvqHLlyrZELyMjQ4888ojWrFmjHj16KCoqSps3b9bYsWO1Y8cOuwfnunfvrk8++USPPfaYateurWXLlqlFixYOxbJw4UJJuqlqbs+ePRUcHKzXX39d586dk3TlS87PP/+sTp06qXjx4tq3b58mTZqkBg0aaOvWrSpQoIAkKTk5WQ0bNlRaWppeffVV+fr6aurUqfLx8bnhfnNzbqQrCclXX32lnj17qmDBgho/frzatWunAwcOqHDhwoqLi9OOHTs0Z84cjR07Vvfcc4+kK9fUjRw7dkySlJ6erj179uiVV15R4cKF1bJlS9s6KSkpql27ts6fP68+ffqocOHCmjlzph555BHNmzdPbdu2lSSHr9+lS5eqc+fOaty4se1+sG3bNv3000964YUX9NBDD6lPnz4aP368XnvtNUVFRUmS7b85eeONN+Th4aEBAwbo1KlTGjNmjB5//HGtXbvWts6kSZP0/PPPq169eurXr5/27dunNm3aqFChQnZJwY089thjatKkiXbv3q3IyEhJV+5P7du3z3bokqP3z82bN6tJkyYKDg7WkCFDlJaWpsGDB2d7Hxo5cqQGDRqkjh07qnv37jp69KgmTJighx56SBs2bMhVL1m9evU0duxYbdmyRZUqVZIkrV69Wh4eHlq9erX69Olja5Okhx56KNvtPPPMMzp06JCWLl2qWbNmZbvO7NmzdebMGT3zzDOyWCwaM2aM4uLitGfPHoeGfZ05c8Z23WYKCgqSh4eHli1bpmbNmql69eoaPHiwPDw8NH36dDVq1EirV6/Wgw8+KMmxz/nNXoc5ye5+M2vWLMXHxys2NlajR4/W+fPnNWnSJNWtW1cbNmxwqNs/u/MhSYULF7ZLGm90H5GkDRs2qGnTpipatKiGDh2q9PR0DRs2zKF7SabevXurUKFCGjx4sPbt26dx48bp+eef1+eff25bx9Hj3rJli+rUqaNixYrZ7rNffPGF2rRpoy+//NJ277neOc7JjfItSTp48KDty8fAgQPl6+urDz/88PZWfw0HnTp1ypBktG7d2qH1N27caEgyunfvbtc+YMAAQ5KxbNkyW1t4eLghyVi1apWt7ciRI4bVajVefPFFW9vevXsNScabb75pt834+HgjPDw8SwyDBw82rj7EsWPHGpKMo0eP5hh35j6mT59ua6tatapRpEgR4/jx47a2TZs2GR4eHsaTTz6ZZX/dunWz22bbtm2NwoUL57jPq4/D19fXMAzDaN++vdG4cWPDMAwjPT3dCA0NNYYOHZrtObh48aKRnp6e5TisVqsxbNgwW9u6deuyHFum+vXrG5KMyZMnZ/ta/fr17dqWLFliSDJGjBhh7Nmzx/Dz8zPatGlzw2M0jCs/7xYtWti1jRs3zpBkfPLJJ7a2S5cuGdHR0Yafn59x+vRp23FJMvz9/Y0jR444tL9MR48eNSQZgwcPtrVNnz7dkGTs3bvXbt3ly5cbkozly5fb2jLP0ccff2xrS01NNUJDQ4127drZ2mbNmmV4eHgYq1evttvm5MmTDUnGTz/9ZBjG/31GevbsabfeY489liXO7FSrVs0IDAzM0n727Fnj6NGjtuXUqVNZjrdu3bpGWlqa3fvOnz+fZVtJSUlZjrlv376GJGPt2rW2tiNHjhgBAQFZzuW1146j58YwDEOS4eXlZezatcvWtmnTJkOSMWHCBFvbm2++me3PMCfx8fGGpCxLsWLFjPXr19utm3msV8d75swZIyIiwihVqpTtc+fo9fvCCy8Y/v7+Wc791ebOnZvl2st07fnMvE6joqKM1NRUW/u7775rSDI2b95sGMaV67Rw4cLGAw88YFy+fNm23owZMwxJWT7f2cn83KalpRmhoaHG8OHDDcMwjK1btxqSjJUrV9qur3Xr1tne5+j9s02bNoa3t7exf/9+W9vWrVsNT09Pu/v4vn37DE9PT2PkyJF28W3evNnIly+fXXtOvxuuduTIEUOSMXHiRMMwDOPkyZOGh4eH0aFDByMkJMS2Xp8+fYygoCAjIyPDMIzsf1f06tXLLtZMmesWLlzYOHHihK39m2++MSQZCxcuvG6MmT/n7Ja9e/caGRkZRtmyZY3Y2FhbfIZx5TMdERFhPPzww3Zt18ruc3696zCn+1N4eLgRHx9v+3dO95szZ84YgYGBxtNPP233/uTkZCMgICBLe27OhyTj8OHDdrE6ch9p1aqVUaBAAePgwYO2tp07dxr58uXL8jPN6ThjYmLszn+/fv0MT09P4+TJk7k+7saNGxuVK1c2Ll68aGvLyMgwateubZQtWzbLvrO7p2f3+83RfKt3796GxWIxNmzYYGs7fvy4ERQUlKv77fU43AV/+vRpSVLBggUdWn/RokWSrnRvXC2z6nVtF1aFChVsVTnpSgWjXLly2rNnj6Mh3lDmt+Jvvvkm2+7C7Bw+fFgbN25Uly5d7KpsVapU0cMPP2w7zqs9++yzdv+uV6+ejh8/bjuHjnjssce0YsUKJScna9myZUpOTs62+126Mh4lc0B0enq6jh8/bhte8Pvvvzu8T6vVqq5duzq0bpMmTfTMM89o2LBhiouLk7e393W7y25k0aJFCg0NVefOnW1t+fPnV58+fXT27FmtXLnSbv127drl6pvp7eLn52dXcfTy8tKDDz5od53OnTtXUVFRKl++vI4dO2ZbGjVqJElavny5pP/7jGRWWDI5Oi3V6dOns+0F+O9//6vg4GDbkt118/TTT2cZG3R1BfPy5cs6fvy4ypQpo8DAQLvraNGiRapVq5atoiJd+bw+/vjjN4zZ0XOTKSYmxlZlk6587vz9/W/5vuDt7a2lS5dq6dKlWrJkiaZMmSI/Pz81b95cO3bssDvWBx98UHXr1rW1+fn5qUePHtq3b59t6Iej129gYKDOnTunpUuX3lL81+ratavd+NDMe2nmefrtt990/PhxPf3003ZDDB5//HEVKlQoV/vy9PRUx44dNWfOHElXHj4qUaKE3f07k6P3z/T0dC1ZskRt2rRRyZIlbetFRUVl6db/6quvlJGRoY4dO9pdQ6GhoSpbtmyWa+hGgoODVb58ea1atUqS9NNPP8nT01MvvfSSUlJStHPnTklXKqB169a96SmhJOnRRx+1O9/X/pxu5PXXX7ddt5lLaGioNm7caBuidfz4cds5OXfunBo3bqxVq1bZfuc5+jm/na693yxdulQnT55U586d7X6Gnp6eqlmzpsM/w+zOx9KlS7P0iN3oPpKenq4ff/xRbdq0sevBK1OmjN0Qphvp0aOH3fVRr149paena//+/bk67hMnTmjZsmXq2LGjrcp77NgxHT9+XLGxsdq5c6cOHjxot+/s7uk5cSTfWrx4saKjo+0eWA4KCnLoPu8oh7vg/f39JV0peTti//798vDwsHsKWboyziowMND2A8l09U0nU6FChfTvv/86GuINPfroo/rwww/VvXt3vfrqq2rcuLHi4uLUvn37HJ9oy4yzXLlyWV6LiorSkiVLsgyqvvZYMm84//77r+083kjz5s1VsGBBff7559q4caMeeOABlSlTJttxFxkZGXr33Xc1ceJE7d271+6hk8zuBUcUK1YsVw85vPXWW/rmm2+0ceNGzZ49W0WKFHH4vdfav3+/ypYtm+XnkNnlc+31EhERcdP7uhXFixfP8guoUKFC+uOPP2z/3rlzp7Zt25ZjgnzkyBFJ//cZufrGKGV/rWWnYMGCOn78eJb2nj172rqRc+qez+78XbhwQQkJCZo+fboOHjxoNybu1KlTtv+/f/9+1axZM8v7HYnb0XOTyVn3BU9PzyzTCTVv3lxly5bVwIEDbQ/S5HSsV1+XlSpVcvj67dmzp7744gs1a9ZMxYoVU5MmTdSxY0c1bdr0lo7nevecq/d/7f04X758N/WE82OPPabx48dr06ZNmj17tjp16pRtYubo/fPMmTO6cOGCypYtm2W9cuXK2X3R37lzpwzDyHZdSTc1g0m9evVs+1i9erVq1KihGjVqKCgoSKtXr1ZISIg2bdqUYxHAUTf6Od1I5cqVs50GKzNJjo+Pz/G9p06dUqFChRz+nN9O195vMuPN/OJ5LUd/T+Z0Pq51o/vIkSNHdOHChSyfDynrZyY3+7n25+voce/atUuGYWjQoEEaNGhQtuseOXJExYoVs/07N78THbmv7t+/P9vZBHJzPm4kVwloWFiY/vzzz1ztwNFvizll7ld/OHK7j2uf/vXx8dGqVau0fPlyfffdd1q8eLE+//xzNWrUSD/88MNte1rsVo4lk9VqVVxcnGbOnKk9e/Zcd1qPUaNGadCgQerWrZuGDx9uGxPUt29fhyu9khwaw3e1DRs22BKGzZs321V/nC23sebE0WsnkyM/24yMDFWuXFnvvPNOtuuWKFEil1Fmr3z58tq4caMOHjxodyO69957de+990pSjk/pZnf+evfurenTp6tv376Kjo62/bGHTp065eo6up7cnpvb8VlyVPHixVWuXDlbJcwZihQpoo0bN2rJkiX6/vvv9f3332v69Ol68skns31gyVGuPE+SVLNmTUVGRqpv377au3fvLSdmuZGRkSGLxaLvv/8+2+PO7bMBklS3bl198MEH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XJxatWqljRs3qnv37nr11VedddoAwBR0wQPI0wzDUGJiopYsWaLevXvr6NGj8vX11Ycffmjrev/kk0+UkZGhDz/8UBaLRZI0ffp0BQYGasWKFWrSpInGjRungQMHKi4uTpI0efJkLVmyJMf97tixQ1988YWWLl2qmJgYSVLp0qVtr2d21xcpUkSBgYGSrlRMR40apR9//FHR0dG296xZs0ZTpkxR/fr1NWnSJEVGRurtt9+WJJUrV06bN2/W6NGjb+NZAwBzkYACyJO+/fZb+fn56fLly8rIyNBjjz2mIUOGqFevXqpcubLduM9NmzZp165dKliwoN02Ll68qN27d+vUqVM6fPiwatasaXstX758qlGjRpZu+EwbN26Up6en6tev73DMu3bt0vnz5/Xwww/btV+6dEnVqlWTJG3bts0uDkm2ZBUA7hYkoADypIYNG2rSpEny8vJSWFiY8uX7v9uZr6+v3bpnz55V9erV9emnn2bZTnBw8E3t38fHJ9fvOXv2rCTpu+++U7Fixexes1qtNxUHAORFJKAA8iRfX1+VKVPGoXXvv/9+ff755ypSpIj8/f2zXado0aJau3atHnroIUlSWlqa1q9fr/vvvz/b9StXrqyMjAytXLnS1gV/tcwKbHp6uq2tQoUKslqtOnDgQI6V06ioKC1YsMCu7ZdffrnxQQJAHsJDSADueo8//rjuuecetW7dWqtXr9bevXu1YsUK9enTR//8848k6YUXXtAbb7yh+fPn66+//lLPnj2vO4dnqVKlFB8fr27dumn+/Pm2bX7xxReSpPDwcFksFn377bc6evSozp49q4IFC2rAgAHq16+fZs6cqd27d+v333/XhAkTNHPmTEnSs88+q507d+qll17S9u3bNXv2bM2YMcPZpwgAXIoEFMBdr0CBAlq1apVKliypuLg4RUVF6amnntLFixdtFdEXX3xRTzzxhOLj4xUdHa2CBQuqbdu2193upEmT1L59e/Xs2VPly5fX008/rXPnzkmSihUrpqFDh+rVV19VSEiInn/+eUnS8OHDNWjQICUkJCgqKkpNmzbVd999p4iICElSyZIl9eWXX2r+/Pm67777NHnyZI0aNcqJZwcAXM9i5DTCHgAAAHACKqAAAABwKRJQAAAAuBQJKAAAAFyKBBQAAAAuRQIKAAAAlyIBBQAAgEuRgAIAAMClSEABAADgUiSgAAAAcCkSUAAAALgUCSgAAABc6v8BnieEprw7MTkAAAAASUVORK5CYII=\n"
          },
          "metadata": {}
        }
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "a8e21e8f",
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 206
        },
        "outputId": "7ef303fe-b6aa-42cc-bf70-a81eec932464"
      },
      "outputs": [
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "   Pregnancies  Glucose  BloodPressure  SkinThickness  Insulin   BMI  \\\n",
              "0            6      148             72             35        0  33.6   \n",
              "1            1       85             66             29        0  26.6   \n",
              "2            8      183             64              0        0  23.3   \n",
              "3            1       89             66             23       94  28.1   \n",
              "4            0      137             40             35      168  43.1   \n",
              "\n",
              "   DiabetesPedigreeFunction  Age  Outcome  \n",
              "0                     0.627   50        1  \n",
              "1                     0.351   31        0  \n",
              "2                     0.672   32        1  \n",
              "3                     0.167   21        0  \n",
              "4                     2.288   33        1  "
            ],
            "text/html": [
              "\n",
              "  <div id=\"df-bebd83f8-b871-4547-a1fc-2a1fd66f51fd\" class=\"colab-df-container\">\n",
              "    <div>\n",
              "<style scoped>\n",
              "    .dataframe tbody tr th:only-of-type {\n",
              "        vertical-align: middle;\n",
              "    }\n",
              "\n",
              "    .dataframe tbody tr th {\n",
              "        vertical-align: top;\n",
              "    }\n",
              "\n",
              "    .dataframe thead th {\n",
              "        text-align: right;\n",
              "    }\n",
              "</style>\n",
              "<table border=\"1\" class=\"dataframe\">\n",
              "  <thead>\n",
              "    <tr style=\"text-align: right;\">\n",
              "      <th></th>\n",
              "      <th>Pregnancies</th>\n",
              "      <th>Glucose</th>\n",
              "      <th>BloodPressure</th>\n",
              "      <th>SkinThickness</th>\n",
              "      <th>Insulin</th>\n",
              "      <th>BMI</th>\n",
              "      <th>DiabetesPedigreeFunction</th>\n",
              "      <th>Age</th>\n",
              "      <th>Outcome</th>\n",
              "    </tr>\n",
              "  </thead>\n",
              "  <tbody>\n",
              "    <tr>\n",
              "      <th>0</th>\n",
              "      <td>6</td>\n",
              "      <td>148</td>\n",
              "      <td>72</td>\n",
              "      <td>35</td>\n",
              "      <td>0</td>\n",
              "      <td>33.6</td>\n",
              "      <td>0.627</td>\n",
              "      <td>50</td>\n",
              "      <td>1</td>\n",
              "    </tr>\n",
              "    <tr>\n",
              "      <th>1</th>\n",
              "      <td>1</td>\n",
              "      <td>85</td>\n",
              "      <td>66</td>\n",
              "      <td>29</td>\n",
              "      <td>0</td>\n",
              "      <td>26.6</td>\n",
              "      <td>0.351</td>\n",
              "      <td>31</td>\n",
              "      <td>0</td>\n",
              "    </tr>\n",
              "    <tr>\n",
              "      <th>2</th>\n",
              "      <td>8</td>\n",
              "      <td>183</td>\n",
              "      <td>64</td>\n",
              "      <td>0</td>\n",
              "      <td>0</td>\n",
              "      <td>23.3</td>\n",
              "      <td>0.672</td>\n",
              "      <td>32</td>\n",
              "      <td>1</td>\n",
              "    </tr>\n",
              "    <tr>\n",
              "      <th>3</th>\n",
              "      <td>1</td>\n",
              "      <td>89</td>\n",
              "      <td>66</td>\n",
              "      <td>23</td>\n",
              "      <td>94</td>\n",
              "      <td>28.1</td>\n",
              "      <td>0.167</td>\n",
              "      <td>21</td>\n",
              "      <td>0</td>\n",
              "    </tr>\n",
              "    <tr>\n",
              "      <th>4</th>\n",
              "      <td>0</td>\n",
              "      <td>137</td>\n",
              "      <td>40</td>\n",
              "      <td>35</td>\n",
              "      <td>168</td>\n",
              "      <td>43.1</td>\n",
              "      <td>2.288</td>\n",
              "      <td>33</td>\n",
              "      <td>1</td>\n",
              "    </tr>\n",
              "  </tbody>\n",
              "</table>\n",
              "</div>\n",
              "    <div class=\"colab-df-buttons\">\n",
              "\n",
              "  <div class=\"colab-df-container\">\n",
              "    <button class=\"colab-df-convert\" onclick=\"convertToInteractive('df-bebd83f8-b871-4547-a1fc-2a1fd66f51fd')\"\n",
              "            title=\"Convert this dataframe to an interactive table.\"\n",
              "            style=\"display:none;\">\n",
              "\n",
              "  <svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\" viewBox=\"0 -960 960 960\">\n",
              "    <path d=\"M120-120v-720h720v720H120Zm60-500h600v-160H180v160Zm220 220h160v-160H400v160Zm0 220h160v-160H400v160ZM180-400h160v-160H180v160Zm440 0h160v-160H620v160ZM180-180h160v-160H180v160Zm440 0h160v-160H620v160Z\"/>\n",
              "  </svg>\n",
              "    </button>\n",
              "\n",
              "  <style>\n",
              "    .colab-df-container {\n",
              "      display:flex;\n",
              "      gap: 12px;\n",
              "    }\n",
              "\n",
              "    .colab-df-convert {\n",
              "      background-color: #E8F0FE;\n",
              "      border: none;\n",
              "      border-radius: 50%;\n",
              "      cursor: pointer;\n",
              "      display: none;\n",
              "      fill: #1967D2;\n",
              "      height: 32px;\n",
              "      padding: 0 0 0 0;\n",
              "      width: 32px;\n",
              "    }\n",
              "\n",
              "    .colab-df-convert:hover {\n",
              "      background-color: #E2EBFA;\n",
              "      box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15);\n",
              "      fill: #174EA6;\n",
              "    }\n",
              "\n",
              "    .colab-df-buttons div {\n",
              "      margin-bottom: 4px;\n",
              "    }\n",
              "\n",
              "    [theme=dark] .colab-df-convert {\n",
              "      background-color: #3B4455;\n",
              "      fill: #D2E3FC;\n",
              "    }\n",
              "\n",
              "    [theme=dark] .colab-df-convert:hover {\n",
              "      background-color: #434B5C;\n",
              "      box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15);\n",
              "      filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3));\n",
              "      fill: #FFFFFF;\n",
              "    }\n",
              "  </style>\n",
              "\n",
              "    <script>\n",
              "      const buttonEl =\n",
              "        document.querySelector('#df-bebd83f8-b871-4547-a1fc-2a1fd66f51fd button.colab-df-convert');\n",
              "      buttonEl.style.display =\n",
              "        google.colab.kernel.accessAllowed ? 'block' : 'none';\n",
              "\n",
              "      async function convertToInteractive(key) {\n",
              "        const element = document.querySelector('#df-bebd83f8-b871-4547-a1fc-2a1fd66f51fd');\n",
              "        const dataTable =\n",
              "          await google.colab.kernel.invokeFunction('convertToInteractive',\n",
              "                                                    [key], {});\n",
              "        if (!dataTable) return;\n",
              "\n",
              "        const docLinkHtml = 'Like what you see? Visit the ' +\n",
              "          '<a target=\"_blank\" href=https://colab.research.google.com/notebooks/data_table.ipynb>data table notebook</a>'\n",
              "          + ' to learn more about interactive tables.';\n",
              "        element.innerHTML = '';\n",
              "        dataTable['output_type'] = 'display_data';\n",
              "        await google.colab.output.renderOutput(dataTable, element);\n",
              "        const docLink = document.createElement('div');\n",
              "        docLink.innerHTML = docLinkHtml;\n",
              "        element.appendChild(docLink);\n",
              "      }\n",
              "    </script>\n",
              "  </div>\n",
              "\n",
              "\n",
              "    <div id=\"df-11e4f6e7-db80-4202-bb1d-295affa01458\">\n",
              "      <button class=\"colab-df-quickchart\" onclick=\"quickchart('df-11e4f6e7-db80-4202-bb1d-295affa01458')\"\n",
              "                title=\"Suggest charts\"\n",
              "                style=\"display:none;\">\n",
              "\n",
              "<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\"viewBox=\"0 0 24 24\"\n",
              "     width=\"24px\">\n",
              "    <g>\n",
              "        <path d=\"M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z\"/>\n",
              "    </g>\n",
              "</svg>\n",
              "      </button>\n",
              "\n",
              "<style>\n",
              "  .colab-df-quickchart {\n",
              "      --bg-color: #E8F0FE;\n",
              "      --fill-color: #1967D2;\n",
              "      --hover-bg-color: #E2EBFA;\n",
              "      --hover-fill-color: #174EA6;\n",
              "      --disabled-fill-color: #AAA;\n",
              "      --disabled-bg-color: #DDD;\n",
              "  }\n",
              "\n",
              "  [theme=dark] .colab-df-quickchart {\n",
              "      --bg-color: #3B4455;\n",
              "      --fill-color: #D2E3FC;\n",
              "      --hover-bg-color: #434B5C;\n",
              "      --hover-fill-color: #FFFFFF;\n",
              "      --disabled-bg-color: #3B4455;\n",
              "      --disabled-fill-color: #666;\n",
              "  }\n",
              "\n",
              "  .colab-df-quickchart {\n",
              "    background-color: var(--bg-color);\n",
              "    border: none;\n",
              "    border-radius: 50%;\n",
              "    cursor: pointer;\n",
              "    display: none;\n",
              "    fill: var(--fill-color);\n",
              "    height: 32px;\n",
              "    padding: 0;\n",
              "    width: 32px;\n",
              "  }\n",
              "\n",
              "  .colab-df-quickchart:hover {\n",
              "    background-color: var(--hover-bg-color);\n",
              "    box-shadow: 0 1px 2px rgba(60, 64, 67, 0.3), 0 1px 3px 1px rgba(60, 64, 67, 0.15);\n",
              "    fill: var(--button-hover-fill-color);\n",
              "  }\n",
              "\n",
              "  .colab-df-quickchart-complete:disabled,\n",
              "  .colab-df-quickchart-complete:disabled:hover {\n",
              "    background-color: var(--disabled-bg-color);\n",
              "    fill: var(--disabled-fill-color);\n",
              "    box-shadow: none;\n",
              "  }\n",
              "\n",
              "  .colab-df-spinner {\n",
              "    border: 2px solid var(--fill-color);\n",
              "    border-color: transparent;\n",
              "    border-bottom-color: var(--fill-color);\n",
              "    animation:\n",
              "      spin 1s steps(1) infinite;\n",
              "  }\n",
              "\n",
              "  @keyframes spin {\n",
              "    0% {\n",
              "      border-color: transparent;\n",
              "      border-bottom-color: var(--fill-color);\n",
              "      border-left-color: var(--fill-color);\n",
              "    }\n",
              "    20% {\n",
              "      border-color: transparent;\n",
              "      border-left-color: var(--fill-color);\n",
              "      border-top-color: var(--fill-color);\n",
              "    }\n",
              "    30% {\n",
              "      border-color: transparent;\n",
              "      border-left-color: var(--fill-color);\n",
              "      border-top-color: var(--fill-color);\n",
              "      border-right-color: var(--fill-color);\n",
              "    }\n",
              "    40% {\n",
              "      border-color: transparent;\n",
              "      border-right-color: var(--fill-color);\n",
              "      border-top-color: var(--fill-color);\n",
              "    }\n",
              "    60% {\n",
              "      border-color: transparent;\n",
              "      border-right-color: var(--fill-color);\n",
              "    }\n",
              "    80% {\n",
              "      border-color: transparent;\n",
              "      border-right-color: var(--fill-color);\n",
              "      border-bottom-color: var(--fill-color);\n",
              "    }\n",
              "    90% {\n",
              "      border-color: transparent;\n",
              "      border-bottom-color: var(--fill-color);\n",
              "    }\n",
              "  }\n",
              "</style>\n",
              "\n",
              "      <script>\n",
              "        async function quickchart(key) {\n",
              "          const quickchartButtonEl =\n",
              "            document.querySelector('#' + key + ' button');\n",
              "          quickchartButtonEl.disabled = true;  // To prevent multiple clicks.\n",
              "          quickchartButtonEl.classList.add('colab-df-spinner');\n",
              "          try {\n",
              "            const charts = await google.colab.kernel.invokeFunction(\n",
              "                'suggestCharts', [key], {});\n",
              "          } catch (error) {\n",
              "            console.error('Error during call to suggestCharts:', error);\n",
              "          }\n",
              "          quickchartButtonEl.classList.remove('colab-df-spinner');\n",
              "          quickchartButtonEl.classList.add('colab-df-quickchart-complete');\n",
              "        }\n",
              "        (() => {\n",
              "          let quickchartButtonEl =\n",
              "            document.querySelector('#df-11e4f6e7-db80-4202-bb1d-295affa01458 button');\n",
              "          quickchartButtonEl.style.display =\n",
              "            google.colab.kernel.accessAllowed ? 'block' : 'none';\n",
              "        })();\n",
              "      </script>\n",
              "    </div>\n",
              "\n",
              "    </div>\n",
              "  </div>\n"
            ],
            "application/vnd.google.colaboratory.intrinsic+json": {
              "type": "dataframe",
              "summary": "{\n  \"name\": \"display(df\",\n  \"rows\": 5,\n  \"fields\": [\n    {\n      \"column\": \"Pregnancies\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 3,\n        \"min\": 0,\n        \"max\": 8,\n        \"num_unique_values\": 4,\n        \"samples\": [\n          1,\n          0,\n          6\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"Glucose\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 41,\n        \"min\": 85,\n        \"max\": 183,\n        \"num_unique_values\": 5,\n        \"samples\": [\n          85,\n          137,\n          183\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"BloodPressure\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 12,\n        \"min\": 40,\n        \"max\": 72,\n        \"num_unique_values\": 4,\n        \"samples\": [\n          66,\n          40,\n          72\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"SkinThickness\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 14,\n        \"min\": 0,\n        \"max\": 35,\n        \"num_unique_values\": 4,\n        \"samples\": [\n          29,\n          23,\n          35\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"Insulin\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 76,\n        \"min\": 0,\n        \"max\": 168,\n        \"num_unique_values\": 3,\n        \"samples\": [\n          0,\n          94,\n          168\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"BMI\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 7.749387072536769,\n        \"min\": 23.3,\n        \"max\": 43.1,\n        \"num_unique_values\": 5,\n        \"samples\": [\n          26.6,\n          43.1,\n          23.3\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"DiabetesPedigreeFunction\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 0.8456568452983751,\n        \"min\": 0.167,\n        \"max\": 2.288,\n        \"num_unique_values\": 5,\n        \"samples\": [\n          0.351,\n          2.288,\n          0.672\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"Age\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 10,\n        \"min\": 21,\n        \"max\": 50,\n        \"num_unique_values\": 5,\n        \"samples\": [\n          31,\n          33,\n          32\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"Outcome\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 0,\n        \"min\": 0,\n        \"max\": 1,\n        \"num_unique_values\": 2,\n        \"samples\": [\n          0,\n          1\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    }\n  ]\n}"
            }
          },
          "metadata": {}
        }
      ],
      "source": [
        "import pandas as pd\n",
        "\n",
        "df = pd.read_csv(\"/content/diabetes.csv\")\n",
        "display(df.head())"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "fa13e207"
      },
      "outputs": [],
      "source": [
        "X = df.drop('Outcome', axis=1)\n",
        "y = df['Outcome']"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "369ad021"
      },
      "outputs": [],
      "source": [
        "from sklearn.model_selection import train_test_split\n",
        "\n",
        "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=42)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "394fc1ec"
      },
      "source": [
        "# Task\n",
        "Improve the accuracy of the classification model and display a confusion matrix."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "5aa8f100"
      },
      "source": [
        "## Handle data imbalance\n",
        "\n",
        "### Subtask:\n",
        "Apply techniques like SMOTE to address the class imbalance in the dataset.\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "ba9b5e9f"
      },
      "source": [
        "**Reasoning**:\n",
        "Apply SMOTE to the training data to address class imbalance and display the class distribution before and after SMOTE.\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "f13d7048",
        "outputId": "ed096a96-bdad-4fb5-f5de-e099bd239dd4"
      },
      "source": [
        "from imblearn.over_sampling import SMOTE\n",
        "\n",
        "# Instantiate SMOTE\n",
        "smote = SMOTE(random_state=42)\n",
        "\n",
        "# Apply SMOTE to the training data\n",
        "X_train_resampled, y_train_resampled = smote.fit_resample(X_train, y_train)\n",
        "\n",
        "# Print class distribution before and after SMOTE\n",
        "print(\"Original training data class distribution:\")\n",
        "print(y_train.value_counts())\n",
        "print(\"\\nResampled training data class distribution:\")\n",
        "print(y_train_resampled.value_counts())"
      ],
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Original training data class distribution:\n",
            "Outcome\n",
            "0    377\n",
            "1    199\n",
            "Name: count, dtype: int64\n",
            "\n",
            "Resampled training data class distribution:\n",
            "Outcome\n",
            "1    377\n",
            "0    377\n",
            "Name: count, dtype: int64\n"
          ]
        }
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "583d9198"
      },
      "source": [
        "## Re-evaluate models with balanced data\n",
        "\n",
        "### Subtask:\n",
        "Train and evaluate the previously explored models (Logistic Regression, Random Forest, Gradient Boosting, SVM) on the balanced data (`X_train_resampled`, `y_train_resampled`).\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "63785400"
      },
      "source": [
        "**Reasoning**:\n",
        "Train and evaluate the previously explored models on the balanced data as instructed.\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "3246019d",
        "outputId": "4127d6b9-f513-4220-8cb3-4466431d2b3e"
      },
      "source": [
        "from sklearn.linear_model import LogisticRegression\n",
        "from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier\n",
        "from sklearn.svm import SVC\n",
        "from sklearn.metrics import accuracy_score, classification_report\n",
        "\n",
        "# Logistic Regression\n",
        "lr_model = LogisticRegression(random_state=42, max_iter=1000)\n",
        "lr_model.fit(X_train_resampled, y_train_resampled)\n",
        "y_pred_lr = lr_model.predict(X_test)\n",
        "accuracy_lr = accuracy_score(y_test, y_pred_lr)\n",
        "report_lr = classification_report(y_test, y_pred_lr)\n",
        "\n",
        "print(\"Logistic Regression Results with Balanced Data:\")\n",
        "print(f\"Accuracy: {accuracy_lr}\")\n",
        "print(\"Classification Report:\")\n",
        "print(report_lr)\n",
        "\n",
        "# RandomForestClassifier\n",
        "rf_model = RandomForestClassifier(random_state=42)\n",
        "rf_model.fit(X_train_resampled, y_train_resampled)\n",
        "y_pred_rf = rf_model.predict(X_test)\n",
        "accuracy_rf = accuracy_score(y_test, y_pred_rf)\n",
        "report_rf = classification_report(y_test, y_pred_rf)\n",
        "\n",
        "print(\"\\nRandomForestClassifier Results with Balanced Data:\")\n",
        "print(f\"Accuracy: {accuracy_rf}\")\n",
        "print(\"Classification Report:\")\n",
        "print(report_rf)\n",
        "\n",
        "# GradientBoostingClassifier\n",
        "gb_model = GradientBoostingClassifier(random_state=42)\n",
        "gb_model.fit(X_train_resampled, y_train_resampled)\n",
        "y_pred_gb = gb_model.predict(X_test)\n",
        "accuracy_gb = accuracy_score(y_test, y_pred_gb)\n",
        "report_gb = classification_report(y_test, y_pred_gb)\n",
        "\n",
        "print(\"\\nGradientBoostingClassifier Results with Balanced Data:\")\n",
        "print(f\"Accuracy: {accuracy_gb}\")\n",
        "print(\"Classification Report:\")\n",
        "print(report_gb)\n",
        "\n",
        "# Support Vector Machine\n",
        "svm_model = SVC(random_state=42)\n",
        "svm_model.fit(X_train_resampled, y_train_resampled)\n",
        "y_pred_svm = svm_model.predict(X_test)\n",
        "accuracy_svm = accuracy_score(y_test, y_pred_svm)\n",
        "report_svm = classification_report(y_test, y_pred_svm)\n",
        "\n",
        "print(\"\\nSupport Vector Machine Results with Balanced Data:\")\n",
        "print(f\"Accuracy: {accuracy_svm}\")\n",
        "print(\"Classification Report:\")\n",
        "print(report_svm)"
      ],
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Logistic Regression Results with Balanced Data:\n",
            "Accuracy: 0.6927083333333334\n",
            "Classification Report:\n",
            "              precision    recall  f1-score   support\n",
            "\n",
            "           0       0.81      0.68      0.74       123\n",
            "           1       0.56      0.71      0.62        69\n",
            "\n",
            "    accuracy                           0.69       192\n",
            "   macro avg       0.68      0.70      0.68       192\n",
            "weighted avg       0.72      0.69      0.70       192\n",
            "\n",
            "\n",
            "RandomForestClassifier Results with Balanced Data:\n",
            "Accuracy: 0.765625\n",
            "Classification Report:\n",
            "              precision    recall  f1-score   support\n",
            "\n",
            "           0       0.85      0.76      0.81       123\n",
            "           1       0.65      0.77      0.70        69\n",
            "\n",
            "    accuracy                           0.77       192\n",
            "   macro avg       0.75      0.77      0.75       192\n",
            "weighted avg       0.78      0.77      0.77       192\n",
            "\n",
            "\n",
            "GradientBoostingClassifier Results with Balanced Data:\n",
            "Accuracy: 0.7083333333333334\n",
            "Classification Report:\n",
            "              precision    recall  f1-score   support\n",
            "\n",
            "           0       0.83      0.68      0.75       123\n",
            "           1       0.57      0.75      0.65        69\n",
            "\n",
            "    accuracy                           0.71       192\n",
            "   macro avg       0.70      0.72      0.70       192\n",
            "weighted avg       0.74      0.71      0.71       192\n",
            "\n",
            "\n",
            "Support Vector Machine Results with Balanced Data:\n",
            "Accuracy: 0.671875\n",
            "Classification Report:\n",
            "              precision    recall  f1-score   support\n",
            "\n",
            "           0       0.78      0.67      0.72       123\n",
            "           1       0.53      0.67      0.59        69\n",
            "\n",
            "    accuracy                           0.67       192\n",
            "   macro avg       0.66      0.67      0.66       192\n",
            "weighted avg       0.69      0.67      0.68       192\n",
            "\n"
          ]
        }
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "3301ea7e"
      },
      "source": [
        "## Hyperparameter tuning on balanced data\n",
        "\n",
        "### Subtask:\n",
        "Perform hyperparameter tuning for the best performing model(s) on the balanced data (`X_train_resampled`, `y_train_resampled`) using GridSearchCV or RandomizedSearchCV.\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "e947b113"
      },
      "source": [
        "**Reasoning**:\n",
        "Train and evaluate RandomForestClassifier and GradientBoostingClassifier models as instructed.\n",
        "\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "ffd7efd3"
      },
      "source": [
        "## Evaluate final model\n",
        "\n",
        "### Subtask:\n",
        "Evaluate the final chosen model with the best hyperparameters on the test set using appropriate metrics (accuracy, precision, recall, F1-score, AUC-ROC).\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "92ee0c55"
      },
      "source": [
        "**Reasoning**:\n",
        "Evaluate the tuned GradientBoostingClassifier model on the test set using accuracy, precision, recall, F1-score, and AUC-ROC.\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "a585ddac",
        "outputId": "ffe3a677-cdbd-4c91-b238-9f7ea736059c"
      },
      "source": [
        "from sklearn.metrics import accuracy_score, classification_report, roc_auc_score, precision_score, recall_score, f1_score\n",
        "\n",
        "# Instantiate the final GradientBoostingClassifier model using the best hyperparameters found during the hyperparameter tuning step\n",
        "# and train it on the resampled training data.\n",
        "gb_model_final = GradientBoostingClassifier(**best_params, random_state=42)\n",
        "gb_model_final.fit(X_train_resampled, y_train_resampled)\n",
        "\n",
        "# Predict the target variable for the test set (X_test) using the trained model.\n",
        "y_pred_final = gb_model_final.predict(X_test)\n",
        "y_pred_proba_final = gb_model_final.predict_proba(X_test)[:, 1] # Get probabilities for AUC-ROC\n",
        "\n",
        "# Calculate the evaluation metrics.\n",
        "accuracy_final = accuracy_score(y_test, y_pred_final)\n",
        "precision_final = precision_score(y_test, y_pred_final)\n",
        "recall_final = recall_score(y_test, y_pred_final)\n",
        "f1_final = f1_score(y_test, y_pred_final)\n",
        "auc_roc_final = roc_auc_score(y_test, y_pred_proba_final)\n",
        "\n",
        "# Print the calculated evaluation metrics.\n",
        "print(\"Evaluation Metrics for Tuned GradientBoostingClassifier on Test Set:\")\n",
        "print(f\"Accuracy: {accuracy_final:.4f}\")\n",
        "print(f\"Precision: {precision_final:.4f}\")\n",
        "print(f\"Recall: {recall_final:.4f}\")\n",
        "print(f\"F1-score: {f1_final:.4f}\")\n",
        "print(f\"AUC-ROC: {auc_roc_final:.4f}\")\n",
        "\n",
        "# Also print the classification report for a comprehensive view\n",
        "print(\"\\nClassification Report:\")\n",
        "print(classification_report(y_test, y_pred_final))"
      ],
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Evaluation Metrics for Tuned GradientBoostingClassifier on Test Set:\n",
            "Accuracy: 0.7031\n",
            "Precision: 0.5682\n",
            "Recall: 0.7246\n",
            "F1-score: 0.6369\n",
            "AUC-ROC: 0.7806\n",
            "\n",
            "Classification Report:\n",
            "              precision    recall  f1-score   support\n",
            "\n",
            "           0       0.82      0.69      0.75       123\n",
            "           1       0.57      0.72      0.64        69\n",
            "\n",
            "    accuracy                           0.70       192\n",
            "   macro avg       0.69      0.71      0.69       192\n",
            "weighted avg       0.73      0.70      0.71       192\n",
            "\n"
          ]
        }
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "35afecb3"
      },
      "source": [
        "## Visualize results\n",
        "\n",
        "### Subtask:\n",
        "Display the confusion matrix and other relevant visualizations for the final model.\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "6ff53d36"
      },
      "source": [
        "**Reasoning**:\n",
        "Display the confusion matrix for the final model as instructed.\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 564
        },
        "id": "65f6d310",
        "outputId": "d95983ea-4d9f-48f5-8a88-807a262cb67c"
      },
      "source": [
        "from sklearn.metrics import confusion_matrix\n",
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "\n",
        "# Generate the confusion matrix for the predictions of the tuned Gradient Boosting model with feature engineering\n",
        "# Assuming 'gb_model_final' and 'X_test', 'y_test' are available from previous steps\n",
        "y_pred_final_diabetes = gb_model_final.predict(X_test)\n",
        "cm = confusion_matrix(y_test, y_pred_final_diabetes)\n",
        "\n",
        "# Display the confusion matrix using a heatmap\n",
        "plt.figure(figsize=(8, 6))\n",
        "sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=['0', '1'], yticklabels=['0', '1'])\n",
        "plt.xlabel('Predicted')\n",
        "plt.ylabel('Actual')\n",
        "plt.title('Confusion Matrix for Tuned Gradient Boosting Model with Feature Engineering')\n",
        "plt.show()"
      ],
      "execution_count": null,
      "outputs": [
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "<Figure size 800x600 with 2 Axes>"
            ],
            "image/png": "iVBORw0KGgoAAAANSUhEUgAAAqAAAAIjCAYAAADcGKmzAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjAsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvlHJYcgAAAAlwSFlzAAAPYQAAD2EBqD+naQAAWC9JREFUeJzt3Xl8TOf7//H3JGQSWSWVxBqxlFiKRksstVZQilg+uoZWtShFV/181NZKqwul1lZRrS601RVVamtTVUXVvmuR2EoIEknO7w+/zNdIIhMyc8S8nn3Mo3LPmXOuc3Lm5Jrrvs89FsMwDAEAAAAu4mF2AAAAAHAvJKAAAABwKRJQAAAAuBQJKAAAAFyKBBQAAAAuRQIKAAAAlyIBBQAAgEuRgAIAAMClSEABAADgUkUuAd21a5fatGmjwMBAWSwWLVy4sFDXv3//flksFs2ePbtQ11uUNW/eXM2bNy+09Z09e1Z9+vRReHi4LBaLBg8eXGjrvllYLBaNHDnS7DAKZPbs2bJYLNq/f7+trbDPHXfnjsdz5MiRslgs1/TaXr16qWLFioUb0P9XkL8V2cu+8cYbTokFrlWxYkX16tXL7DDylds1+UZyTQnonj179Pjjj6tSpUry9vZWQECAGjdurLffflvnz58v7BjtxMfHa/PmzXrllVc0d+5c1a9f36nbc6VevXrJYrEoICAg1+O4a9cuWSyWa76QHT58WCNHjtTGjRsLIdprN3bsWM2ePVv9+vXT3Llz9dBDDzllO9l/uPJ7FPU/6CkpKXrllVdUv359BQYGymq1KiIiQv/5z3/03XffmR2e0/3yyy8aOXKkTp065dDy2e+z7EexYsVUvnx59ezZU1u3bnVusA7YunWrRo4cecP90ahYsaIsFotat26d6/Pvvvuu7Zj+/vvvLo7uxvD999875YPjihUr8rx+9ezZs9C3J92456F09eNhsVj0ySefmB0iHFCsoC/47rvv1L17d1mtVj388MOqVauW0tPTtWbNGj377LPasmWLZsyY4YxYdf78eSUmJuq///2vnnzySadsIyIiQufPn1fx4sWdsv78FCtWTOfOndM333yjHj162D330UcfydvbWxcuXLimdR8+fFijRo1SxYoVVbduXYdf98MPP1zT9vKyfPlyNWzYUCNGjCjU9V4pLi5OVapUsf189uxZ9evXT126dFFcXJytPSwszKlxONPu3bsVGxurAwcOqEuXLnr44Yfl5+env//+W99//706dOigDz74wGlJfn4K+9zJzS+//KJRo0apV69eCgoKcug1VqtV7733niQpIyNDe/bs0bRp07R48WJt3bpVZcqUcWLEV7d161aNGjVKzZs3z1G9c8XxvBpvb2/99NNPSkpKUnh4uN1z13t9Kmpy+1vx/fffa/LkyU7rvRg0aJDuuOMOuzZnVXivdh7eKHI7HpIUExPj1O3u2LFDHh43fgfyQw89pJ49e8pqtZodSq4KlIDu27dPPXv2VEREhJYvX67SpUvbnhswYIB2797t1IrLsWPHJMnhPzLXwmKxyNvb22nrz4/ValXjxo318ccf50hA582bp3vuuUeff/65S2I5d+6cSpQoIS8vr0Jd79GjR1WjRo1CW19GRoaysrJyxHnbbbfptttus/18/Phx9evXT7fddpsefPDBQtu+WTIyMtSlSxclJydr5cqVaty4sd3zI0aM0A8//KDMzMyrric1NVW+vr5OibGwz53CUqxYsRznQMOGDdWhQwd99913euyxx0yK7OrMPp6NGzfWunXr9Omnn+qpp56ytf/zzz9avXq1unTp4rLrk9nM+FvRtGlTdevWzaXbLGyFeb0x63jcqAldtuxj7OnpKU9PT7PDyVOBUvhx48bp7Nmzmjlzpl3yma1KlSp2F6WMjAyNGTNGlStXltVqVcWKFfXiiy8qLS3N7nUVK1ZUhw4dtGbNGt15553y9vZWpUqV9MEHH9iWGTlypCIiIiRJzz77rCwWi+1TWV7jfHIbO7R06VI1adJEQUFB8vPzU7Vq1fTiiy/ans9rXM/y5cvVtGlT+fr6KigoSJ06ddK2bdty3d7u3btt1ZjAwED17t1b586dy/vAXuH+++/XokWL7LoU161bp127dun+++/PsfzJkyf1zDPPqHbt2vLz81NAQIDatWunTZs22ZZZsWKF7ZNi7969bV0V2fvZvHlz1apVS+vXr9ddd92lEiVK2I7LlePO4uPj5e3tnWP/Y2NjVbJkSR0+fDjX/cruNtm3b5++++47WwzZXTxHjx7Vo48+qrCwMHl7e6tOnTqaM2eO3TouH0s1YcIE27l1rV2neY2RyY51xYoVtrbsY7R161a1aNFCJUqUUNmyZTVu3Lgc601LS9OIESNUpUoVWa1WlS9fXs8991yOcz8tLU1DhgxRqVKl5O/vr3vvvVf//POPQ7HPnz9ff/31l4YPH54j+czWpk0btWvXLsf+rly5Uv3791doaKjKlSsnSTpw4ID69++vatWqycfHRyEhIerevXuuXXBbtmxRy5Yt5ePjo3Llyunll19WVlZWjuVyG7Po6LGxWCx68skntXDhQtWqVUtWq1U1a9bU4sWLbcuMHDlSzz77rCQpMjIyxzlVENkVvWLF7D+X7927V927d1dwcLBKlCihhg0b5vpB25HzV5I++eQTRUdHy9/fXwEBAapdu7befvttSZd+P927d5cktWjRwrY/2efhlccz+zz97LPP9Morr6hcuXLy9vZWq1attHv37hzbnjx5sipVqiQfHx/deeedWr16dYHGlXp7eysuLk7z5s2za//4449VsmRJxcbG5vo6R66fkrRmzRrdcccd8vb2VuXKlTV9+vQ8Y/nwww8VHR0tHx8fBQcHq2fPnvr7778d2o/LDR06VCEhITIMw9Y2cOBAWSwWTZw40daWnJwsi8WiqVOnSsr5t6JXr16aPHmyJNl1B19pxowZtuvWHXfcoXXr1hU45rysXbtWbdu2VWBgoEqUKKFmzZrp559/tlvGkfd5fudhXmPUrxwbebXrjSQtWrTIdl74+/vrnnvu0ZYtWwrteGTHmt91JNuKFStUv359u/Mvtzwir/38+eefNXToUJUqVUq+vr7q0qWLrXB2OUf3e/v27erWrZuCg4Pl7e2t+vXr6+uvv7Zb5mrHOLe/b47kW9n+/PNPNWvWzO46P2vWrEIbV1qgCug333yjSpUqqVGjRg4t36dPH82ZM0fdunXT008/rbVr1yohIUHbtm3Tl19+abfs7t271a1bNz366KOKj4/X+++/r169eik6Olo1a9ZUXFycgoKCNGTIEN13331q3769/Pz8ChK+tmzZog4dOui2227T6NGjZbVatXv37hxv0Cv9+OOPateunSpVqqSRI0fq/PnzmjRpkho3bqw//vgjR/Lbo0cPRUZGKiEhQX/88Yfee+89hYaG6rXXXnMozri4OD3xxBP64osv9Mgjj0i6VP2sXr26br/99hzL7927VwsXLlT37t0VGRmp5ORkTZ8+Xc2aNbN1J0ZFRWn06NF66aWX1LdvXzVt2lSS7H6XJ06cULt27dSzZ089+OCDeXZNv/32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2dp27dplFCtWLMfvNK/9bN26td3xHzJkiOHp6WmcOnWqwPvdqlUro3bt2saFCxdsbVlZWUajRo2MqlWr5th2btf03P6+OZpvDRw40LBYLMaGDRtsbSdOnDCCg4MLdL29Goe74FNSUiRJ/v7+Di3//fffS7rUvXG57KrXlV1YNWrUsFXlpEsVjGrVqmnv3r2Ohpiv7E/FX331Va7dhbk5cuSINm7cqF69etlV2W677Tbdfffdtv283BNPPGH3c9OmTXXixAnbMXTE/fffrxUrVigpKUnLly9XUlJSrt3v0qXxKNkDojMzM3XixAnb8II//vjD4W1arVb17t3boWXbtGmjxx9/XKNHj1ZcXJy8vb2v2l2Wn++//17h4eG67777bG3FixfXoEGDdPbsWa1cudJu+a5duxbok2lh8fPzs6s4enl56c4777Q7T+fPn6+oqChVr15dx48ftz1atmwpSfrpp58k/d97JLvCks3RaalSUlJy7QX473//q1KlStkeuZ03jz32WI6xQZdXMC9evKgTJ06oSpUqCgoKsjuPvv/+ezVs2NBWUZEuvV8feOCBfGN29Nhka926ta3KJl163wUEBFz3dcHb21tLly7V0qVLtWTJEk2fPl1+fn5q3769du7cabevd955p5o0aWJr8/PzU9++fbV//37b0A9Hz9+goCClpqZq6dKl1xX/lXr37m03PjT7Wpp9nH7//XedOHFCjz32mN0QgwceeEAlS5Ys0LY8PT3Vo0cPffzxx5Iu3XxUvnx5u+t3Nkevn5mZmVqyZIk6d+6sChUq2JaLiorK0a3/xRdfKCsrSz169LA7h8LDw1W1atUc51B+SpUqperVq2vVqlWSpJ9//lmenp569tlnlZycrF27dkm6VAFt0qTJNU8JJUn/+c9/7I73lb+n/Lz00ku28zb7ER4ero0bN9qGaJ04ccJ2TFJTU9WqVSutWrXK9jfP0fd5YbryerN06VKdOnVK9913n93v0NPTUw0aNHD4d5jb8Vi6dGmOHrH8riOZmZn68ccf1blzZ7sevCpVqtgNYcpP37597c6Ppk2bKjMzUwcOHCjQfp88eVLLly9Xjx49bFXe48eP68SJE4qNjdWuXbt06NAhu23ndk3PiyP51uLFixUTE2N3w3JwcLBD13lHOdwFHxAQIOlSydsRBw4ckIeHh91dyNKlcVZB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giis83rnzp3asWOH6tSpY2tr3769fvvtNyUmJtraUlNTNWPGDFWsWNE2n62j5++VQyY8PDxsyV/2e6cw36fZ6tevr5CQEL377rvKyMiwtX/00UfXPJyhT58+GjFihF0icyVHr5+enp6KjY3VwoULdfDgQdty27Zt05IlS+zWGRcXJ09PT40aNSrH+WoYRq7DUvITGRmpsmXLavz48bp48aJtWrOmTZtqz549WrBggRo2bJhvZc4ZvztHREdHq3LlynrjjTfsPkBlu3wqIEff51fbl8qVK+foKZgxY0a+cw5ni42NVUBAgMaOHauLFy9eNV5XyB6Ss3DhQrtpBHfv3q1FixYV2nYc3e/Q0FA1b95c06dPzzWpd8XxiY2NVWJiot03J548edKh67yjClQBrVy5subNm6f//Oc/ioqKsvsmpF9++cU27Ygk1alTR/Hx8ZoxY4ZOnTqlZs2a6bffftOcOXPUuXNnu0/h16tnz556/vnn1aVLFw0aNMg2rcGtt95qN6h69OjRWrVqle655x5FRETo6NGjmjJlisqVK2d3k8GVXn/9dbVr104xMTF69NFHbdOIBAYGOvX7uj08PPS///0v3+U6dOig0aNHq3fv3mrUqJE2b96sjz76yPYpKlvlypUVFBSkadOmyd/fX76+vmrQoEGBx1MuX75cU6ZM0YgRI2zTQs2aNUvNmzfX8OHDc50XMz99+/bV9OnT1atXL61fv14VK1bUggUL9PPPP2vChAkO3/xWUDVr1lTDhg01bNgwnTx5UsHBwfrkk0/s/kgX1EMPPaTPPvtMTzzxhH766Sc1btxYmZmZ2r59uz777DMtWbJE9evXV926dXXfffdpypQpOn36tBo1aqRly5Y5/AmzePHi+vLLLxUbG6smTZooLi7ONrfcoUOH9PXXX+vgwYMOf9jr0KGD5s6dq8DAQNWoUUOJiYn68ccfc4wjfu655zR37ly1bdtWTz31lG0apuwqYGEcm4LIrkr997//Vc+ePVW8eHF17Njxqj0TGRkZ+vDDDyVd6u7av3+/pk2bpqysLLtv6HrhhRf08ccfq127dho0aJCCg4M1Z84c7du3T59//rmt2uno+dunTx+dPHlSLVu2VLly5XTgwAFNmjRJdevWtfUU1a1bV56ennrttdd0+vRpWa1WtWzZ8rrGWHt5eWnkyJEaOHCgWrZsqR49emj//v2aPXu2KleufE2Vu4iICIeuf45eP0eNGqXFixeradOm6t+/vy2Br1mzpt15VblyZb388ssaNmyYbSopf39/7du3T19++aX69u2rZ555psD707RpU33yySeqXbu2rWfk9ttvl6+vr3bu3OnQMIPsc3HQoEGKjY2Vp6en074q83IeHh5677331K5dO9WsWVO9e/dW2bJldejQIf30008KCAiwTdvm6Pv8audhnz599MQTT6hr1666++67tWnTJi1ZssSux+1qAgICNHXqVD300EO6/fbb1bNnT5UqVUoHDx7Ud999p8aNG+udd97Jdz2rV6/O9Zu3rvwSEkeMHDlSP/zwgxo3bqx+/fopMzNT77zzjmrVqlVoX19dkP2ePHmymjRpotq1a+uxxx5TpUqVlJycrMTERP3zzz9283w7w3PPPacPP/xQd999twYOHGibhqlChQo6efJk4VT7r+XW+Z07dxqPPfaYUbFiRcPLy8vw9/c3GjdubEyaNMluyoCLFy8ao0aNMiIjI43ixYsb5cuXN4YNG2a3jGHkPi2PYeScciSvaZgMwzB++OEHo1atWoaXl5dRrVo148MPP8wxDdOyZcuMTp06GWXKlDG8vLyMMmXKGPfdd5+xc+fOHNu4cqqiH3/80WjcuLHh4+NjBAQEGB07djS2bt1qt0z29q6c5imvqX6udPk0THnJaxqmp59+2ihdurTh4+NjNG7c2EhMTMx1+qSvvvrKqFGjhm1qiez9bNasmVGzZs1ct3n5elJSUoyIiAjj9ttvt5vOxTAuTTnh4eFhJCYmXnUf8vp9JycnG7179zZuueUWw8vLy6hdu3aO38PVzoH85DYNk2EYxp49e4zWrVsbVqvVCAsLM1588UVj6dKluU7DlNsxym2ql/T0dOO1114zatasaVitVqNkyZJGdHS0MWrUKLtpkc6fP28MGjTICAkJMXx9fY2OHTsaf//9t0PTMGU7deqUMXr0aKNevXqGn5+f4eXlZZQvX97o1q1bjuldcpsmJ9u///5rO/5+fn5GbGyssX379hxTjhiGYfz5559Gs2bNDG9vb6Ns2bLGmDFjjJkzZ+Y7DVNBjo0kY8CAATnizC2eMWPGGGXLljU8PDzyfa/lNg1TQECA0apVK+PHH3/MsfyePXuMbt26GUFBQYa3t7dx5513Gt9++22O5Rw5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BVAqoAAAAHAtKqAAAAAmc7cxoCSgAAAAJnOz/JMueAAAALgWFVAAAACTuVsXPBVQAAAAuBQVUAAAAJNRAQUAAACciAooAACAydysAEoFFAAAAK5FBRQAAMBk7jYGlAQUAADAZG6Wf9IFDwAAANciAQUAADCZxWJx2qOgDh06pAcffFAhISHy8fFR7dq19fvvv9ueNwxDL730kkqXLi0fHx+1bt1au3btKtA2SEABAAAgSfr333/VuHFjFS9eXIsWLdLWrVv15ptvqmTJkrZlxo0bp4kTJ2ratGlau3atfH19FRsbqwsXLji8HcaAAgAAmOxGGQP62muvqXz58po1a5atLTIy0vZvwzA0YcIE/e9//1OnTp0kSR988IHCwsK0cOFC9ezZ06HtUAEFAAC4iaWlpSklJcXukZaWluuyX3/9terXr6/u3bsrNDRU9erV07vvvmt7ft++fUpKSlLr1q1tbYGBgWrQoIESExMdjokEFAAAwGQeFovTHgkJCQoMDLR7JCQk5BrH3r17NXXqVFWtWlVLlixRv379NGjQIM2ZM0eSlJSUJEkKCwuze11YWJjtOUfQBQ8AAHATGzZsmIYOHWrXZrVac102KytL9evX19ixYyVJ9erV019//aVp06YpPj6+0GKiAgoAAGAyi8V5D6vVqoCAALtHXglo6dKlVaNGDbu2qKgoHTx4UJIUHh4uSUpOTrZbJjk52facI0hAAQAATHajTMPUuHFj7dixw65t586dioiIkHTphqTw8HAtW7bM9nxKSorWrl2rmJgYh7dDFzwAAAAkSUOGDFGjRo00duxY9ejRQ7/99ptmzJihGTNmSLqUKA8ePFgvv/yyqlatqsjISA0fPlxlypRR586dHd4OCSgAAIDJPG6QaZjuuOMOffnllxo2bJhGjx6tyMhITZgwQQ888IBtmeeee06pqanq27evTp06pSZNmmjx4sXy9vZ2eDsWwzAMZ+yAO/Op96TZIQBwkq/njTQ7BABOcnfULaZtu93UtU5b96J+DZy27mtFBRQAAMBk1/KVmUUZNyEBAADApaiAAgAAmMzNCqBUQAEAAOBaVEABAABMZpF7lUBJQAEAAEx2o0zD5Cp0wQMAAMClqIACAACYjGmYAAAAACeiAgoAAGAyNyuAUgEFAACAa1EBBQAAMJmHm5VAqYACAADApaiAAgAAmMzN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9Vb5+PioRYsWdnECwM2ABBTATcHHx0fp6emSpGXLlmnHjh1aunSpvv32W128eFGxsbHy9/fX6tWr9fPPP8vPz09t27a1vebNN9/U7Nmz9f7772vNmjU6efKkvvzyy6tu8+GHH9bHH3+siRMnatu2bZo+fbr8/PxUvnx5ff7555KkHTt26MiRI3r77bclSQkJCfrggw80bdo0bdmyRUOGDNGDDz6olStXSrqUKMfFxaljx47auHGj+vTpoxdeeMFZhw0ATEEXPIAizTAMLVu2TEuWLNHAgQN17Ngx+fr66r333rN1vX/44YfKysrSe++9J4vFIkmaNWuWgoKCtGLFCrVp00YTJkzQsGHDFBcXJ0maNm2alixZkud2d+7cqc8++0xLly5V69atJUmVKlWyPZ/dXR8aGqqgoCBJlyqmY8eO1Y8//qiYmBjba9asWaPp06erWbNmmjp1qipXrqw333xTklStWjVt3rxZr732WiEeNQAwFwkogCLp22+/lZ+fny5evKisrCzdf//9GjlypAYMGKDatWvbjfvctGmTdu/eLX9/f7t1XLhwQXv27NHp06d15MgRNWjQwPZcsWLFVL9+/Rzd8Nk2btwoT09PNWvWzOGYd+/erXPnzunuu++2a09PT1e9evUkSdu2bbOLQ5ItWQWAmwUJKIAiqUWLFpo6daq8vLxUpkwZFSv2f5czX19fu2XPnj2r6OhoffTRRznWU6pUqWvavo+PT4Ffc/bsWUnSd999p7Jly9o9Z7VarykOACiKSEABFEm+vr6qUqWKQ8vefvvt+vTTTxUaGqqAgIBclyldurTWrl2ru+66S5KUkZGh9evX6/bbb891+dq1aysrK0srV660dcFfLrsCm5mZaWurUaOGrFarDh48mGflNCoqSl9//bVd26+//pr/TgJAEcJNSABueg888IBuueUWderUSatXr9a+ffu0YsUKDRo0SP/8848k6amnntKrr76qhQsXavv27erfv/9V5/CsWLGi4uPj9cgjj2jhwoW2dX722WeSpIiICFksFn377bc6duyYzp49K39/fz3zzDMaMmSI5syZoz179uiPP/7QpEmTNGfOHEnSE088oV27dunZZ5/Vjh07NG/ePM2ePdvZhwgAXIoEFMBNr0SJElq1apUqVKiguLg4RUVF6dFHH9WFCxdsFdGnn35aDz30kOLj4xUTEyN/f3916dLlquudOnWqunXrpv79+6t69ep67LHHlJqaKkkqW7asRo0apRdeeEFhYWF68sknJUljxozR8OHDlZCQoKioKLVt21bfffedIiMjJUkVKlTQ559/roULF6pOnTqaNm2axo4d68SjAwCuZzHyGmEPAAAAOAEVUAAAALgUCSgAAABcigQUAAAALkUCCgAAAJciAQUAAIBLkYACAADApUhAAQAA4FIkoAAAAHApElAAAAC4FAkoAAAAXIoEFAAAAC71/wCcJ70oL8x9rwAAAABJRU5ErkJggg==\n"
          },
          "metadata": {}
        }
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "dfa1a4d7"
      },
      "source": [
        "## Summarize findings\n",
        "\n",
        "### Subtask:\n",
        "Provide a summary of the steps taken, the results achieved, and insights for future work.\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "df43cac1"
      },
      "source": [
        "## Summary:\n",
        "\n",
        "### Data Analysis Key Findings\n",
        "\n",
        "*   The original training data had a class imbalance with 377 instances of class 0 and 199 instances of class 1. After applying SMOTE, the resampled training data was balanced with 377 instances for both classes.\n",
        "*   After re-evaluating models with the balanced data, the Gradient Boosting Classifier achieved the highest ROC_AUC score of approximately 0.9038 during cross-validation on the resampled training data with the best hyperparameters: `{'learning_rate': 0.1, 'max_depth': 5, 'min_samples_split': 4, 'n_estimators': 200}`.\n",
        "*   Evaluating the tuned Gradient Boosting Classifier on the test set resulted in the following metrics: Accuracy: 0.7031, Precision: 0.5682, Recall: 0.7246, F1-score: 0.6369, and AUC-ROC: 0.7806.\n",
        "*   The confusion matrix for the final model visualizes the prediction performance, showing the counts of true positives, true negatives, false positives, and false negatives.\n",
        "\n",
        "### Insights or Next Steps\n",
        "\n",
        "*   Although SMOTE and hyperparameter tuning improved the model's ability to identify positive cases (increased recall), exploring additional techniques like adjusting the classification threshold or using cost-sensitive learning could further enhance recall for the positive class.\n",
        "*   Investigating feature engineering, exploring different algorithms (Random Forests, SVMs), or utilizing ensemble methods could potentially lead to further improvements in overall model performance and robustness.\n"
      ]
    }
  ],
  "metadata": {
    "colab": {
      "provenance": [],
      "include_colab_link": true
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    },
    "language_info": {
      "name": "python"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}